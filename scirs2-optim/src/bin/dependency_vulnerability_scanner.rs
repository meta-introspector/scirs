//! Dependency Vulnerability Scanner
//!
//! A specialized tool for scanning Rust project dependencies for known security
//! vulnerabilities, outdated packages, and license compliance issues.

use clap::{Arg, ArgMatches, Command};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};
use std::process;
use std::time::{Duration, SystemTime};

/// Main entry point for the dependency vulnerability scanner
#[allow(dead_code)]
fn main() {
    let matches = Command::new("Dependency Vulnerability Scanner")
        .version("0.1.0")
        .author("SciRS2 Development Team")
        .about("Scan Rust project dependencies for security vulnerabilities")
        .arg(
            Arg::new("project-path")
                .short('p')
                .long("project")
                .value_name("PATH")
                .help("Path to the Rust project to scan")
                .required(false)
                .default_value("."),
        )
        .arg(
            Arg::new("output")
                .short('o')
                .long("output")
                .value_name("FILE")
                .help("Output file for scan results")
                .required(false),
        )
        .arg(
            Arg::new("format")
                .short('f')
                .long("format")
                .value_name("FORMAT")
                .help("Output format: json, csv, markdown")
                .default_value("markdown")
                .possible_values(&["json", "csv", "markdown"]),
        )
        .arg(
            Arg::new("update-db")
                .long("update-database")
                .help("Update vulnerability database before scanning")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("check-outdated")
                .long("check-outdated")
                .help("Check for outdated dependencies")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("check-licenses")
                .long("check-licenses")
                .help("Check license compatibility")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("severity-filter")
                .long("min-severity")
                .value_name("LEVEL")
                .help("Minimum severity level to report")
                .default_value("low")
                .possible_values(&["info", "low", "medium", "high", "critical"]),
        )
        .arg(
            Arg::new("json-advisory")
                .long("advisory-db")
                .value_name("PATH")
                .help("Path to advisory database (JSON format)")
                .required(false),
        )
        .arg(
            Arg::new("verbose")
                .short('v')
                .long("verbose")
                .help("Enable verbose output")
                .action(clap::ArgAction::SetTrue),
        )
        .get_matches();

    if let Err(e) = run_dependency_scan(&matches) {
        eprintln!("Error: {}", e);
        process::exit(1);
    }
}

/// Run the dependency vulnerability scan
#[allow(dead_code)]
fn run_dependency_scan(matches: &ArgMatches) -> Result<(), Box<dyn std::error::Error>> {
    let project_path = Path::new(matches.get_one::<String>("project-path").unwrap());
    let verbose = matches.get_flag("verbose");

    if verbose {
        println!(
            "üîç Starting dependency vulnerability scan for: {}",
            project_path.display()
        );
    }

    // Initialize scanner
    let mut scanner = DependencyVulnerabilityScanner::new(verbose);

    // Update database if requested
    if matches.get_flag("update-db") {
        if verbose {
            println!("üì• Updating vulnerability database...");
        }
        scanner.update_vulnerability_database()?;
    }

    // Load advisory database if provided
    if let Some(advisory_path) = matches.get_one::<String>("json-advisory") {
        scanner.load_advisory_database(Path::new(advisory_path))?;
    }

    // Configure scan options
    let scan_config = ScanConfig {
        check_outdated: matches.get_flag("check-outdated"),
        check_licenses: matches.get_flag("check-licenses"),
        min_severity: parse_severity(matches.get_one::<String>("severity-filter").unwrap())?,
        verbose,
    };

    // Run the scan
    let scan_result = scanner.scan_project(project_path, &scan_config)?;

    // Generate report
    let format = matches.get_one::<String>("format").unwrap();
    let report = generate_report(&scan_result, format)?;

    // Output results
    if let Some(output_file) = matches.get_one::<String>("output") {
        fs::write(output_file, &report)?;
        if verbose {
            println!("üìù Scan results written to: {}", output_file);
        }
    } else {
        println!("{}", report);
    }

    // Print summary
    print_scan_summary(&scan_result, verbose);

    // Exit with appropriate code
    let exit_code = determine_exit_code(&scan_result, &scan_config);
    if exit_code != 0 {
        process::exit(exit_code);
    }

    Ok(())
}

/// Dependency vulnerability scanner
struct DependencyVulnerabilityScanner {
    vulnerability_db: VulnerabilityDatabase,
    license_db: LicenseDatabase,
    verbose: bool,
}

/// Vulnerability database
#[derive(Debug, Default)]
struct VulnerabilityDatabase {
    advisories: HashMap<String, Vec<VulnerabilityAdvisory>>,
    last_updated: Option<SystemTime>,
}

/// License database
#[derive(Debug, Default)]
struct LicenseDatabase {
    license_compatibility: HashMap<String, LicenseInfo>,
}

/// Vulnerability advisory
#[derive(Debug, Clone, Serialize, Deserialize)]
struct VulnerabilityAdvisory {
    id: String,
    package: String,
    title: String,
    description: String,
    severity: Severity,
    cvss_score: Option<f64>,
    affected_versions: String,
    patched_versions: Vec<String>,
    published_date: String,
    references: Vec<String>,
    categories: Vec<String>,
}

/// License information
#[derive(Debug, Clone)]
struct LicenseInfo {
    name: String,
    is_copyleft: bool,
    commercial_use: bool,
    distribution: bool,
    modification: bool,
    private_use: bool,
    compatibility_level: CompatibilityLevel,
}

/// License compatibility level
#[derive(Debug, Clone, PartialEq)]
enum CompatibilityLevel {
    HighlyCompatible,
    Compatible,
    Questionable,
    Incompatible,
    Unknown,
}

/// Scan configuration
#[derive(Debug, Clone)]
struct ScanConfig {
    check_outdated: bool,
    check_licenses: bool,
    min_severity: Severity,
    verbose: bool,
}

/// Severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
enum Severity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

/// Complete scan result
#[derive(Debug, Serialize, Deserialize)]
struct ScanResult {
    timestamp: SystemTime,
    project_path: PathBuf,
    scan_duration: Duration,
    dependencies_scanned: usize,
    vulnerabilities: Vec<VulnerabilityFinding>,
    outdated_packages: Vec<OutdatedPackage>,
    license_issues: Vec<LicenseIssue>,
    summary: ScanSummary,
    recommendations: Vec<String>,
}

/// Vulnerability finding
#[derive(Debug, Serialize, Deserialize)]
struct VulnerabilityFinding {
    package_name: String,
    current_version: String,
    advisory: VulnerabilityAdvisory,
    fix_available: bool,
    recommended_version: Option<String>,
    impact_assessment: ImpactAssessment,
}

/// Impact assessment
#[derive(Debug, Serialize, Deserialize)]
struct ImpactAssessment {
    exploitability: f64,
    business_impact: f64,
    remediation_effort: f64,
    priority_score: f64,
}

/// Outdated package information
#[derive(Debug, Serialize, Deserialize)]
struct OutdatedPackage {
    name: String,
    current_version: String,
    latest_version: String,
    versions_behind: usize,
    risk_level: RiskLevel,
}

/// Risk level for outdated packages
#[derive(Debug, Serialize, Deserialize)]
enum RiskLevel {
    Low,
    Medium,
    High,
}

/// License issue
#[derive(Debug, Serialize, Deserialize)]
struct LicenseIssue {
    package_name: String,
    license: String,
    issue_type: LicenseIssueType,
    description: String,
    recommendation: String,
}

/// License issue types
#[derive(Debug, Serialize, Deserialize)]
enum LicenseIssueType {
    Incompatible,
    Copyleft,
    Unknown,
    Restrictive,
}

/// Scan summary
#[derive(Debug, Serialize, Deserialize)]
struct ScanSummary {
    total_vulnerabilities: usize,
    critical_vulnerabilities: usize,
    high_vulnerabilities: usize,
    medium_vulnerabilities: usize,
    low_vulnerabilities: usize,
    outdated_packages: usize,
    license_issues: usize,
    overall_risk_score: f64,
    security_grade: SecurityGrade,
}

/// Security grade
#[derive(Debug, Serialize, Deserialize)]
enum SecurityGrade {
    A, // Excellent
    B, // Good
    C, // Fair
    D, // Poor
    F, // Critical issues
}

impl DependencyVulnerabilityScanner {
    /// Create new scanner
    fn new(verbose: bool) -> Self {
        Self {
            vulnerability_db: VulnerabilityDatabase::default(),
            license_db: LicenseDatabase::new(),
            verbose,
        }
    }

    /// Update vulnerability database
    fn update_vulnerability_database(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // In a real implementation, this would fetch from RustSec, OSV, etc.
        // For this example, we'll populate with some sample data
        self.vulnerability_db = VulnerabilityDatabase::create_sample_db();
        self.vulnerability_db.last_updated = Some(SystemTime::now());

        if self.verbose {
            println!("‚úÖ Vulnerability database updated successfully");
        }

        Ok(())
    }

    /// Load advisory database from JSON file
    fn load_advisory_database(&mut self, path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        if !path.exists() {
            return Err(format!("Advisory database file not found: {}", path.display()).into());
        }

        let content = fs::read_to_string(path)?;
        let advisories: Vec<VulnerabilityAdvisory> = serde_json::from_str(&content)?;

        // Group advisories by package name
        for advisory in advisories {
            self.vulnerability_db
                .advisories
                .entry(advisory.package.clone())
                .or_insert_with(Vec::new)
                .push(advisory);
        }

        if self.verbose {
            println!("‚úÖ Loaded advisory database from {}", path.display());
        }

        Ok(())
    }

    /// Scan project for dependency vulnerabilities
    fn scan_project(
        &self,
        project_path: &Path,
        config: &ScanConfig,
    ) -> Result<ScanResult, Box<dyn std::error::Error>> {
        let start_time = SystemTime::now();

        // Parse project dependencies
        let dependencies = self.parse_project_dependencies(project_path)?;

        if config.verbose {
            println!("üì¶ Found {} dependencies to scan", dependencies.len());
        }

        // Scan for vulnerabilities
        let vulnerabilities = self.scan_vulnerabilities(&dependencies, config)?;

        // Check for outdated packages
        let outdated_packages = if config.check_outdated {
            self.check_outdated_packages(&dependencies)?
        } else {
            Vec::new()
        };

        // Check license issues
        let license_issues = if config.check_licenses {
            self.check_license_issues(&dependencies)?
        } else {
            Vec::new()
        };

        let scan_duration = start_time.elapsed().unwrap_or(Duration::from_secs(0));

        // Generate summary
        let summary = self.generate_summary(&vulnerabilities, &outdated_packages, &license_issues);

        // Generate recommendations
        let recommendations =
            self.generate_recommendations(&vulnerabilities, &outdated_packages, &license_issues);

        Ok(ScanResult {
            timestamp: start_time,
            project_path: project_path.to_path_buf(),
            scan_duration,
            dependencies_scanned: dependencies.len(),
            vulnerabilities,
            outdated_packages,
            license_issues,
            summary,
            recommendations,
        })
    }

    /// Parse project dependencies from Cargo.toml and Cargo.lock
    fn parse_project_dependencies(
        &self,
        project_path: &Path,
    ) -> Result<Vec<Dependency>, Box<dyn std::error::Error>> {
        let mut dependencies = Vec::new();

        // Parse Cargo.toml for direct dependencies
        let cargo_toml_path = project_path.join("Cargo.toml");
        if cargo_toml_path.exists() {
            let cargo_content = fs::read_to_string(&cargo_toml_path)?;
            let direct_deps = self.parse_cargo_toml(&cargo_content)?;
            dependencies.extend(direct_deps);
        }

        // Parse Cargo.lock for all dependencies (including transitive)
        let cargo_lock_path = project_path.join("Cargo.lock");
        if cargo_lock_path.exists() {
            let lock_content = fs::read_to_string(&cargo_lock_path)?;
            let all_deps = self.parse_cargo_lock(&lock_content)?;

            // Merge with direct dependencies, preferring lock file versions
            for lock_dep in all_deps {
                if let Some(existing) = dependencies.iter_mut().find(|d| d.name == lock_dep.name) {
                    existing.version = lock_dep.version;
                    existing.is_direct = true;
                } else {
                    dependencies.push(lock_dep);
                }
            }
        }

        Ok(dependencies)
    }

    /// Parse dependencies from Cargo.toml
    fn parse_cargo_toml(
        &self,
        content: &str,
    ) -> Result<Vec<Dependency>, Box<dyn std::error::Error>> {
        let mut dependencies = Vec::new();
        let mut in_dependencies = false;

        for line in content.lines() {
            let line = line.trim();

            if line.starts_with("[dependencies]") {
                in_dependencies = true;
                continue;
            } else if line.starts_with('[') && in_dependencies {
                in_dependencies = false;
                continue;
            }

            if in_dependencies && !line.is_empty() && !line.starts_with('#') {
                if let Some(eq_pos) = line.find('=') {
                    let name = line[..eq_pos].trim().to_string();
                    let version_part = line[eq_pos + 1..].trim();

                    let version = self.extract_version_from_spec(version_part);

                    dependencies.push(Dependency {
                        name,
                        version,
                        is_direct: true,
                        source: DependencySource::CratesIo,
                    });
                }
            }
        }

        Ok(dependencies)
    }

    /// Parse dependencies from Cargo.lock
    fn parse_cargo_lock(
        &self,
        content: &str,
    ) -> Result<Vec<Dependency>, Box<dyn std::error::Error>> {
        let mut dependencies = Vec::new();
        let mut current_package = None;

        for line in content.lines() {
            let line = line.trim();

            if line.starts_with("[[package]]") {
                current_package = Some(Dependency {
                    name: String::new(),
                    version: String::new(),
                    is_direct: false,
                    source: DependencySource::CratesIo,
                });
            } else if let Some(ref mut pkg) = current_package {
                if line.starts_with("name = ") {
                    pkg.name = line
                        .split('=')
                        .nth(1)
                        .unwrap()
                        .trim()
                        .trim_matches('"')
                        .to_string();
                } else if line.starts_with("version = ") {
                    pkg.version = line
                        .split('=')
                        .nth(1)
                        .unwrap()
                        .trim()
                        .trim_matches('"')
                        .to_string();
                } else if line.starts_with("source = ") {
                    let source_str = line.split('=').nth(1).unwrap().trim().trim_matches('"');
                    if source_str.contains("git") {
                        pkg.source = DependencySource::Git;
                    } else if source_str.contains("path") {
                        pkg.source = DependencySource::Path;
                    }
                } else if line.is_empty() && !pkg.name.is_empty() {
                    dependencies.push(pkg.clone());
                    current_package = None;
                }
            }
        }

        // Add the last package if file doesn't end with empty line
        if let Some(pkg) = current_package {
            if !pkg.name.is_empty() {
                dependencies.push(pkg);
            }
        }

        Ok(dependencies)
    }

    /// Extract version from dependency specification
    fn extract_version_from_spec(&self, spec: &str) -> String {
        if spec.starts_with('"') && spec.ends_with('"') {
            // Simple version string
            spec.trim_matches('"').to_string()
        } else if spec.starts_with('{') {
            // Complex specification
            if let Some(version_start) = spec.find("version") {
                if let Some(eq_pos) = spec[version_start..].find('=') {
                    let after_eq = &spec[version_start + eq_pos + 1..];
                    if let Some(quote_start) = after_eq.find('"') {
                        if let Some(quote_end) = after_eq[quote_start + 1..].find('"') {
                            return after_eq[quote_start + 1..quote_start + 1 + quote_end]
                                .to_string();
                        }
                    }
                }
            }
            "unknown".to_string()
        } else {
            spec.to_string()
        }
    }

    /// Scan dependencies for known vulnerabilities
    fn scan_vulnerabilities(
        &self,
        dependencies: &[Dependency],
        config: &ScanConfig,
    ) -> Result<Vec<VulnerabilityFinding>, Box<dyn std::error::Error>> {
        let mut findings = Vec::new();

        for dep in dependencies {
            if let Some(advisories) = self.vulnerability_db.advisories.get(&dep.name) {
                for advisory in advisories {
                    if advisory.severity < config.min_severity {
                        continue;
                    }

                    if self.version_is_affected(&dep.version, &advisory.affected_versions) {
                        let impact = self.assess_impact(advisory, dep);
                        let recommended_version = self.find_recommended_version(advisory, dep);

                        findings.push(VulnerabilityFinding {
                            package_name: dep.name.clone(),
                            current_version: dep.version.clone(),
                            advisory: advisory.clone(),
                            fix_available: recommended_version.is_some(),
                            recommended_version,
                            impact_assessment: impact,
                        });
                    }
                }
            }
        }

        // Sort by severity and impact
        findings.sort_by(|a, b| {
            b.advisory.severity.cmp(&a.advisory.severity).then_with(|| {
                b.impact_assessment
                    .priority_score
                    .partial_cmp(&a.impact_assessment.priority_score)
                    .unwrap_or(std::cmp::Ordering::Equal)
            })
        });

        Ok(findings)
    }

    /// Check for outdated packages
    fn check_outdated_packages(
        &self,
        dependencies: &[Dependency],
    ) -> Result<Vec<OutdatedPackage>, Box<dyn std::error::Error>> {
        let mut outdated = Vec::new();

        for dep in dependencies {
            // Simulate checking for latest version
            let latest_version = self.get_latest_version(&dep.name)?;
            if let Some(latest) = latest_version {
                if dep.version != latest {
                    let versions_behind = self.calculate_versions_behind(&dep.version, &latest);
                    let risk_level = self.assess_outdated_risk(versions_behind);

                    outdated.push(OutdatedPackage {
                        name: dep.name.clone(),
                        current_version: dep.version.clone(),
                        latest_version: latest,
                        versions_behind,
                        risk_level,
                    });
                }
            }
        }

        Ok(outdated)
    }

    /// Check for license compatibility issues
    fn check_license_issues(
        &self,
        dependencies: &[Dependency],
    ) -> Result<Vec<LicenseIssue>, Box<dyn std::error::Error>> {
        let mut issues = Vec::new();

        for dep in dependencies {
            let license = self.get_package_license(&dep.name)?;
            if let Some(license_name) = license {
                if let Some(license_info) = self.license_db.license_compatibility.get(&license_name)
                {
                    let issue_type = self.check_license_compatibility(license_info);
                    if let Some(issue_type) = issue_type {
                        issues.push(LicenseIssue {
                            package_name: dep.name.clone(),
                            license: license_name.clone(),
                            issue_type: issue_type.clone(),
                            description: self
                                .get_license_issue_description(&issue_type, &license_name),
                            recommendation: self.get_license_recommendation(&issue_type),
                        });
                    }
                } else {
                    // Unknown license
                    issues.push(LicenseIssue {
                        package_name: dep.name.clone(),
                        license: license_name,
                        issue_type: LicenseIssueType::Unknown,
                        description: "License not recognized or not in compatibility database"
                            .to_string(),
                        recommendation: "Review license terms manually".to_string(),
                    });
                }
            }
        }

        Ok(issues)
    }

    /// Assess impact of vulnerability
    fn assess_impact(
        &self,
        advisory: &VulnerabilityAdvisory,
        dependency: &Dependency,
    ) -> ImpactAssessment {
        let exploitability = match advisory.severity {
            Severity::Critical => 0.9,
            Severity::High => 0.7,
            Severity::Medium => 0.5,
            Severity::Low => 0.3,
            Severity::Info => 0.1,
        };

        let business_impact = if dependency.is_direct { 0.8 } else { 0.4 };

        let remediation_effort = if advisory.patched_versions.is_empty() {
            0.8
        } else {
            0.3
        };

        let priority_score = (exploitability + business_impact) * (1.0 - remediation_effort * 0.3);

        ImpactAssessment {
            exploitability,
            business_impact,
            remediation_effort,
            priority_score,
        }
    }

    /// Find recommended version for fixing vulnerability
    fn find_recommended_version(
        &self,
        advisory: &VulnerabilityAdvisory,
        _dependency: &Dependency,
    ) -> Option<String> {
        // Return the first patched version, or None if no patch available
        advisory.patched_versions.first().cloned()
    }

    /// Check if version is affected by vulnerability
    fn version_is_affected(&self, version: &str, affected_range: &str) -> bool {
        // Simplified version checking - in practice would use proper semver parsing
        // For this example, we'll use basic string comparison
        affected_range.contains(version) || affected_range == "*"
    }

    /// Get latest version of package (simulated)
    fn get_latest_version(
        &self,
        _package_name: &str,
    ) -> Result<Option<String>, Box<dyn std::error::Error>> {
        // In real implementation, would query crates.io API
        // For this example, return a simulated newer version
        Ok(Some("1.0.0".to_string()))
    }

    /// Calculate how many versions behind a package is
    fn calculate_versions_behind(&self, _current: &str, _latest: &str) -> usize {
        // Simplified calculation
        1
    }

    /// Assess risk level for outdated packages
    fn assess_outdated_risk(&self, versions_behind: usize) -> RiskLevel {
        match versions_behind {
            0 => RiskLevel::Low,
            1..=3 => RiskLevel::Medium,
            _ => RiskLevel::High,
        }
    }

    /// Get package license (simulated)
    fn get_package_license(
        &self,
        _package_name: &str,
    ) -> Result<Option<String>, Box<dyn std::error::Error>> {
        // In real implementation, would query crates.io API or parse Cargo.lock
        Ok(Some("MIT".to_string()))
    }

    /// Check license compatibility
    fn check_license_compatibility(&self, license_info: &LicenseInfo) -> Option<LicenseIssueType> {
        match license_info.compatibility_level {
            CompatibilityLevel::Incompatible => Some(LicenseIssueType::Incompatible),
            CompatibilityLevel::Questionable if license_info.is_copyleft => {
                Some(LicenseIssueType::Copyleft)
            }
            CompatibilityLevel::Unknown => Some(LicenseIssueType::Unknown),
            _ => None,
        }
    }

    /// Get description for license issue
    fn get_license_issue_description(
        &self,
        issue_type: &LicenseIssueType,
        license_name: &str,
    ) -> String {
        match issue_type {
            LicenseIssueType::Incompatible => format!(
                "{} license is incompatible with project requirements",
                license_name
            ),
            LicenseIssueType::Copyleft => format!(
                "{} is a copyleft license that may require releasing source code",
                license_name
            ),
            LicenseIssueType::Unknown => format!("{} license is not recognized", license_name),
            LicenseIssueType::Restrictive => {
                format!("{} license has restrictive terms", license_name)
            }
        }
    }

    /// Get recommendation for license issue
    fn get_license_recommendation(&self, issue_type: &LicenseIssueType) -> String {
        match issue_type {
            LicenseIssueType::Incompatible => {
                "Replace with a compatible dependency or obtain appropriate license".to_string()
            }
            LicenseIssueType::Copyleft => {
                "Review copyleft obligations or find alternative dependency".to_string()
            }
            LicenseIssueType::Unknown => {
                "Research license terms and assess compatibility".to_string()
            }
            LicenseIssueType::Restrictive => {
                "Review license restrictions and ensure compliance".to_string()
            }
        }
    }

    /// Generate scan summary
    fn generate_summary(
        &self,
        vulnerabilities: &[VulnerabilityFinding],
        outdated: &[OutdatedPackage],
        license_issues: &[LicenseIssue],
    ) -> ScanSummary {
        let mut critical_vulnerabilities = 0;
        let mut high_vulnerabilities = 0;
        let mut medium_vulnerabilities = 0;
        let mut low_vulnerabilities = 0;

        for vuln in vulnerabilities {
            match vuln.advisory.severity {
                Severity::Critical => critical_vulnerabilities += 1,
                Severity::High => high_vulnerabilities += 1,
                Severity::Medium => medium_vulnerabilities += 1,
                Severity::Low => low_vulnerabilities += 1,
                _ => {}
            }
        }

        let total_vulnerabilities = vulnerabilities.len();
        let outdated_packages = outdated.len();
        let license_issues_count = license_issues.len();

        // Calculate overall risk score
        let risk_score = self.calculate_overall_risk_score(
            critical_vulnerabilities,
            high_vulnerabilities,
            medium_vulnerabilities,
            outdated_packages,
            license_issues_count,
        );

        let security_grade = self.determine_security_grade(
            risk_score,
            critical_vulnerabilities,
            high_vulnerabilities,
        );

        ScanSummary {
            total_vulnerabilities,
            critical_vulnerabilities,
            high_vulnerabilities,
            medium_vulnerabilities,
            low_vulnerabilities,
            outdated_packages,
            license_issues: license_issues_count,
            overall_risk_score: risk_score,
            security_grade,
        }
    }

    /// Calculate overall risk score
    fn calculate_overall_risk_score(
        &self,
        critical: usize,
        high: usize,
        medium: usize,
        outdated: usize,
        license: usize,
    ) -> f64 {
        let vuln_score = critical as f64 * 10.0 + high as f64 * 5.0 + medium as f64 * 2.0;
        let outdated_score = outdated as f64 * 1.0;
        let license_score = license as f64 * 0.5;

        (vuln_score + outdated_score + license_score).min(100.0)
    }

    /// Determine security grade
    fn determine_security_grade(
        &self,
        risk_score: f64,
        critical: usize,
        high: usize,
    ) -> SecurityGrade {
        if critical > 0 {
            SecurityGrade::F
        } else if risk_score >= 20.0 || high > 3 {
            SecurityGrade::D
        } else if risk_score >= 10.0 || high > 0 {
            SecurityGrade::C
        } else if risk_score >= 5.0 {
            SecurityGrade::B
        } else {
            SecurityGrade::A
        }
    }

    /// Generate recommendations
    fn generate_recommendations(
        &self,
        vulnerabilities: &[VulnerabilityFinding],
        outdated: &[OutdatedPackage],
        license_issues: &[LicenseIssue],
    ) -> Vec<String> {
        let mut recommendations = Vec::new();

        if !vulnerabilities.is_empty() {
            recommendations.push(format!(
                "üö® Address {} security vulnerabilities immediately",
                vulnerabilities.len()
            ));

            for vuln in vulnerabilities.iter().take(3) {
                if let Some(ref recommended) = vuln.recommended_version {
                    recommendations.push(format!(
                        "   - Update {} from {} to {}",
                        vuln.package_name, vuln.current_version, recommended
                    ));
                } else {
                    recommendations.push(format!(
                        "   - Review {} vulnerability: {}",
                        vuln.package_name, vuln.advisory.title
                    ));
                }
            }
        }

        if !outdated.is_empty() {
            recommendations.push(format!(
                "üì¶ Update {} outdated dependencies",
                outdated.len()
            ));
        }

        if !license_issues.is_empty() {
            recommendations.push(format!(
                "üìÑ Review {} license compatibility issues",
                license_issues.len()
            ));
        }

        if vulnerabilities.is_empty() && outdated.is_empty() && license_issues.is_empty() {
            recommendations.push(
                "‚úÖ No security issues found. Continue monitoring dependencies regularly."
                    .to_string(),
            );
        }

        recommendations
            .push("üîÑ Set up automated dependency scanning in CI/CD pipeline".to_string());
        recommendations.push("üìÖ Schedule regular dependency updates".to_string());

        recommendations
    }
}

/// Dependency information
#[derive(Debug, Clone)]
struct Dependency {
    name: String,
    version: String,
    is_direct: bool,
    source: DependencySource,
}

/// Dependency source
#[derive(Debug, Clone)]
enum DependencySource {
    CratesIo,
    Git,
    Path,
}

impl VulnerabilityDatabase {
    /// Create sample vulnerability database for demonstration
    fn create_sample_db() -> Self {
        let mut advisories = HashMap::new();

        // Add some example vulnerabilities
        advisories.insert("serde".to_string(), vec![
            VulnerabilityAdvisory {
                id: "RUSTSEC-2022-0001".to_string(),
                package: "serde".to_string(),
                title: "Deserialization of untrusted data in serde".to_string(),
                description: "An issue was discovered in the serde crate where deserialization could lead to code execution".to_string(),
                severity: Severity::High,
                cvss_score: Some(7.5),
                affected_versions: "<1.0.100".to_string(),
                patched_versions: vec!["1.0.100".to_string(), "1.0.101".to_string()],
                published_date: "2022-01-15".to_string(),
                references: vec!["https://rustsec.org/advisories/RUSTSEC-2022-0001".to_string()],
                categories: vec!["code-execution".to_string()],
            }
        ]);

        advisories.insert("regex".to_string(), vec![
            VulnerabilityAdvisory {
                id: "RUSTSEC-2022-0013".to_string(),
                package: "regex".to_string(),
                title: "Regex compilation denial of service".to_string(),
                description: "Certain regex patterns could cause excessive memory consumption during compilation".to_string(),
                severity: Severity::Medium,
                cvss_score: Some(5.3),
                affected_versions: "<1.5.5".to_string(),
                patched_versions: vec!["1.5.5".to_string()],
                published_date: "2022-03-10".to_string(),
                references: vec!["https://rustsec.org/advisories/RUSTSEC-2022-0013".to_string()],
                categories: vec!["denial-of-service".to_string()],
            }
        ]);

        Self {
            advisories,
            last_updated: Some(SystemTime::now()),
        }
    }
}

impl LicenseDatabase {
    /// Create new license database with common licenses
    fn new() -> Self {
        let mut license_compatibility = HashMap::new();

        // MIT License
        license_compatibility.insert(
            "MIT".to_string(),
            LicenseInfo {
                name: "MIT License".to_string(),
                is_copyleft: false,
                commercial_use: true,
                distribution: true,
                modification: true,
                private_use: true,
                compatibility_level: CompatibilityLevel::HighlyCompatible,
            },
        );

        // Apache 2.0
        license_compatibility.insert(
            "Apache-2.0".to_string(),
            LicenseInfo {
                name: "Apache License 2.0".to_string(),
                is_copyleft: false,
                commercial_use: true,
                distribution: true,
                modification: true,
                private_use: true,
                compatibility_level: CompatibilityLevel::HighlyCompatible,
            },
        );

        // GPL-3.0
        license_compatibility.insert(
            "GPL-3.0".to_string(),
            LicenseInfo {
                name: "GNU General Public License v3.0".to_string(),
                is_copyleft: true,
                commercial_use: true,
                distribution: true,
                modification: true,
                private_use: true,
                compatibility_level: CompatibilityLevel::Questionable,
            },
        );

        // BSD-3-Clause
        license_compatibility.insert(
            "BSD-3-Clause".to_string(),
            LicenseInfo {
                name: "BSD 3-Clause License".to_string(),
                is_copyleft: false,
                commercial_use: true,
                distribution: true,
                modification: true,
                private_use: true,
                compatibility_level: CompatibilityLevel::Compatible,
            },
        );

        Self {
            license_compatibility,
        }
    }
}

/// Parse severity from string
#[allow(dead_code)]
fn parse_severity(severity_str: &str) -> Result<Severity, Box<dyn std::error::Error>> {
    match severity_str.to_lowercase().as_str() {
        "info" => Ok(Severity::Info),
        "low" => Ok(Severity::Low),
        "medium" => Ok(Severity::Medium),
        "high" => Ok(Severity::High),
        "critical" => Ok(Severity::Critical),
        _ => Err(format!("Invalid severity level: {}", severity_str).into()),
    }
}

/// Generate report in specified format
#[allow(dead_code)]
fn generate_report(
    scan_result: &ScanResult,
    format: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    match format {
        "json" => Ok(serde_json::to_string_pretty(scan_result)?),
        "csv" => generate_csv_report(scan_result),
        "markdown" => generate_markdown_report(scan_result),
        _ => Err(format!("Unsupported format: {}", format).into()),
    }
}

/// Generate markdown report
#[allow(dead_code)]
fn generate_markdown_report(
    scan_result: &ScanResult,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut report = String::new();

    report.push_str("# Dependency Vulnerability Scan Report\n\n");

    report.push_str(&format!(
        "**Project**: {}\n",
        scan_result.project_path.display()
    ));
    report.push_str(&format!("**Scan Date**: {:?}\n", scan_result.timestamp));
    report.push_str(&format!(
        "**Dependencies Scanned**: {}\n",
        scan_result.dependencies_scanned
    ));
    report.push_str(&format!(
        "**Scan Duration**: {:.2}s\n\n",
        scan_result.scan_duration.as_secs_f64()
    ));

    // Summary
    report.push_str("## Summary\n\n");
    report.push_str(&format!(
        "**Security Grade**: {:?}\n",
        scan_result.summary.security_grade
    ));
    report.push_str(&format!(
        "**Overall Risk Score**: {:.1}/100\n\n",
        scan_result.summary.overall_risk_score
    ));

    report.push_str("### Vulnerabilities Found\n");
    report.push_str(&format!(
        "- **Critical**: {}\n",
        scan_result.summary.critical_vulnerabilities
    ));
    report.push_str(&format!(
        "- **High**: {}\n",
        scan_result.summary.high_vulnerabilities
    ));
    report.push_str(&format!(
        "- **Medium**: {}\n",
        scan_result.summary.medium_vulnerabilities
    ));
    report.push_str(&format!(
        "- **Low**: {}\n",
        scan_result.summary.low_vulnerabilities
    ));
    report.push_str(&format!(
        "- **Outdated Packages**: {}\n",
        scan_result.summary.outdated_packages
    ));
    report.push_str(&format!(
        "- **License Issues**: {}\n\n",
        scan_result.summary.license_issues
    ));

    // Vulnerabilities
    if !scan_result.vulnerabilities.is_empty() {
        report.push_str("## Security Vulnerabilities\n\n");
        for vuln in &scan_result.vulnerabilities {
            report.push_str(&format!(
                "### {} ({})\n",
                vuln.package_name, vuln.current_version
            ));
            report.push_str(&format!("**Advisory ID**: {}\n", vuln.advisory.id));
            report.push_str(&format!("**Severity**: {:?}\n", vuln.advisory.severity));
            if let Some(cvss) = vuln.advisory.cvss_score {
                report.push_str(&format!("**CVSS Score**: {:.1}\n", cvss));
            }
            report.push_str(&format!("**Title**: {}\n", vuln.advisory.title));
            report.push_str(&format!("**Description**: {}\n", vuln.advisory.description));
            if let Some(ref recommended) = vuln.recommended_version {
                report.push_str(&format!("**Recommended Update**: {}\n", recommended));
            }
            report.push_str(&format!(
                "**Priority Score**: {:.2}\n\n",
                vuln.impact_assessment.priority_score
            ));
        }
    }

    // Recommendations
    if !scan_result.recommendations.is_empty() {
        report.push_str("## Recommendations\n\n");
        for (i, rec) in scan_result.recommendations.iter().enumerate() {
            report.push_str(&format!("{}. {}\n", i + 1, rec));
        }
        report.push_str("\n");
    }

    Ok(report)
}

/// Generate CSV report
#[allow(dead_code)]
fn generate_csv_report(scan_result: &ScanResult) -> Result<String, Box<dyn std::error::Error>> {
    let mut csv = String::new();

    // Header
    csv.push_str("Package,Current Version,Vulnerability ID,Severity,CVSS Score,Title,Fix Available,Recommended Version\n");

    // Vulnerability rows
    for vuln in &scan_result.vulnerabilities {
        csv.push_str(&format!(
            "{},{},{},{:?},{},{},{},{}\n",
            vuln.package_name,
            vuln.current_version,
            vuln.advisory.id,
            vuln.advisory.severity,
            vuln.advisory
                .cvss_score
                .map_or("N/A".to_string(), |s| s.to_string()),
            vuln.advisory.title.replace(',', ";"),
            if vuln.fix_available { "Yes" } else { "No" },
            vuln.recommended_version.as_deref().unwrap_or("N/A")
        ));
    }

    Ok(csv)
}

/// Print scan summary to console
#[allow(dead_code)]
fn print_scan_summary(scan_result: &ScanResult, verbose: bool) {
    println!("\nüîç Dependency Scan Summary");
    println!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    println!(
        "üì¶ Dependencies scanned: {}",
        scan_result.dependencies_scanned
    );
    println!(
        "üö® Vulnerabilities found: {}",
        scan_result.summary.total_vulnerabilities
    );
    println!(
        "   ‚îú‚îÄ Critical: {}",
        scan_result.summary.critical_vulnerabilities
    );
    println!("   ‚îú‚îÄ High: {}", scan_result.summary.high_vulnerabilities);
    println!(
        "   ‚îú‚îÄ Medium: {}",
        scan_result.summary.medium_vulnerabilities
    );
    println!("   ‚îî‚îÄ Low: {}", scan_result.summary.low_vulnerabilities);
    println!(
        "üìà Outdated packages: {}",
        scan_result.summary.outdated_packages
    );
    println!("üìÑ License issues: {}", scan_result.summary.license_issues);
    println!(
        "üéØ Security grade: {:?}",
        scan_result.summary.security_grade
    );
    println!(
        "üìä Risk score: {:.1}/100",
        scan_result.summary.overall_risk_score
    );

    if verbose && !scan_result.recommendations.is_empty() {
        println!("\nüí° Top Recommendations:");
        for (i, rec) in scan_result.recommendations.iter().take(3).enumerate() {
            println!("   {}. {}", i + 1, rec);
        }
    }
}

/// Determine exit code based on scan results
#[allow(dead_code)]
fn determine_exit_code(scan_result: &ScanResult, config: &ScanConfig) -> i32 {
    match config.min_severity {
        Severity::Critical => {
            if scan_result.summary.critical_vulnerabilities > 0 {
                1
            } else {
                0
            }
        }
        Severity::High => {
            if scan_result.summary.critical_vulnerabilities
                + scan_result.summary.high_vulnerabilities
                > 0
            {
                1
            } else {
                0
            }
        }
        Severity::Medium => {
            if scan_result.summary.total_vulnerabilities > scan_result.summary.low_vulnerabilities {
                1
            } else {
                0
            }
        }
        _ => {
            if scan_result.summary.total_vulnerabilities > 0 {
                1
            } else {
                0
            }
        }
    }
}
