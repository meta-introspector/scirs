# Unwrap() Usage Report

Total unwrap() calls and unsafe operations found: 3256

## Summary by Type

- Replace with ? operator or .ok_or(): 1648 occurrences
- Division without zero check - use safe_divide(): 1232 occurrences
- Mathematical operation .sqrt() without validation: 171 occurrences
- Use .get() with proper bounds checking: 120 occurrences
- Mathematical operation .powf( without validation: 47 occurrences
- Mathematical operation .ln() without validation: 26 occurrences
- Handle array creation errors properly: 10 occurrences
- Mathematical operation .log() without validation: 2 occurrences

## Detailed Findings


### acceleration.rs

3 issues found:

- Line 337: `let factor = a[[i, k]] / a[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 358: `x[i] = (b[i] - sum) / a[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 422: `Some(x2 - numerator / denominator)`
  - **Fix**: Division without zero check - use safe_divide()

### analysis.rs

24 issues found:

- Line 154: `/ (self.parameter_samples - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 223: `let residual_norm = sum_squares.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 271: `jacobian[[i, j]] = (f_plus[i] - f0[i]) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 360: `let norm = norm_sqr.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 365: `q[[i, j]] = v[i] / norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 671: `let residual_norm = sum_squares.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 729: `let factor = lu[[i, k]] / lu[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 849: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 900: `let step = (domain[dim].1 - domain[dim].0) / (grid_size - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 933: `let residual_norm = sum_squares.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 987: `jacobian[[i, j]] = (f_plus[i] - f0[i]) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1027: `let factor = a[[i, k]] / a[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1069: `let sqrt_disc = discriminant.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1070: `let lambda1 = (trace + sqrt_disc) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1071: `let lambda2 = (trace - sqrt_disc) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1074: `let real_part = trace / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1075: `let imag_part = (-discriminant).sqrt() / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1075: `let imag_part = (-discriminant).sqrt() / 2.0;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1176: `let dx = (domain[0].1 - domain[0].0) / (grid_size - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1177: `let dy = (domain[1].1 - domain[1].0) / (grid_size - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1202: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1240: `let n_steps = (self.integration_time / dt) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1267: `let bifurcations = analyzer.continuation_analysis(system, &initial_guess).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1283: `let result = analyzer.analyze_stability(system, &domain).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### autodiff/dual.rs

21 issues found:

- Line 74: `val: self.val.ln(),`
  - **Fix**: Mathematical operation .ln() without validation
- Line 75: `der: self.der / self.val,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 81: `let sqrt_val = self.val.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 84: `der: self.der / (F::from(2.0).unwrap() * sqrt_val),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 91: `val: self.val.powf(n),`
  - **Fix**: Mathematical operation .powf( without validation
- Line 92: `der: self.der * n * self.val.powf(n - F::one()),`
  - **Fix**: Mathematical operation .powf( without validation
- Line 110: `der: self.der / (cos_val * cos_val),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 143: `der: self.der / (F::one() + self.val * self.val),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 151: `der: self.der / (F::one() - self.val * self.val).sqrt(),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 151: `der: self.der / (F::one() - self.val * self.val).sqrt(),`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 159: `der: -self.der / (F::one() - self.val * self.val).sqrt(),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 159: `der: -self.der / (F::one() - self.val * self.val).sqrt(),`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 168: `der: (self.der * x.val - self.val * x.der) / r2,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 182: `der: (self.der + other.der) / F::from(2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 197: `der: (self.der + other.der) / F::from(2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 204: `let val = self.val.powf(other.val);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 206: `val * (other.der * self.val.ln() + other.val * self.der / self.val)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 206: `val * (other.der * self.val.ln() + other.val * self.der / self.val)`
  - **Fix**: Mathematical operation .ln() without validation
- Line 252: `let inv_val = F::one() / other.val;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 310: `val: self.val / scalar,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 311: `der: self.der / scalar,`
  - **Fix**: Division without zero check - use safe_divide()

### autodiff/forward.rs

6 issues found:

- Line 24: `tolerance: F::from(1e-12).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 160: `let hundred = Dual::constant(F::from(100.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 168: `let x = Array1::from_vec(vec![F::from(1.0).unwrap(), F::from(2.0).unwrap()]);`
  - **Fix**: Handle array creation errors properly
- Line 218: `tolerance: F::from(1e-12).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 326: `let grad = forward_gradient(f, x.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `let jac = forward_jacobian(f, x.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### autodiff/reverse.rs

22 issues found:

- Line 141: `let value = self.nodes[a].value / self.nodes[b].value;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 157: `let value = self.nodes[a].value.powf(n);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 189: `let value = self.nodes[a].value.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 197: `let value = self.nodes[a].value.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 205: `let value = self.nodes[a].value.powf(self.nodes[b].value);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 315: `*self.nodes[*a].gradient.borrow_mut() += grad / b_val;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 316: `*self.nodes[*b].gradient.borrow_mut() -= grad * self.nodes[*a].value / (b_val * ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 322: `*self.nodes[*a].gradient.borrow_mut() += grad * *n * self.nodes[*a].value.powf(*...`
  - **Fix**: Mathematical operation .powf( without validation
- Line 334: `*self.nodes[*a].gradient.borrow_mut() += grad / self.nodes[*a].value;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 337: `*self.nodes[*a].gradient.borrow_mut() += grad / (F::from(2.0).unwrap() * node.va...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 344: `*self.nodes[*a].gradient.borrow_mut() += grad * b_val * a_val.powf(b_val - F::on...`
  - **Fix**: Mathematical operation .powf( without validation
- Line 345: `*self.nodes[*b].gradient.borrow_mut() += grad * node.value * a_val.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 350: `*self.nodes[*a].gradient.borrow_mut() += grad / (cos_val * cos_val);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 371: `*self.nodes[*y].gradient.borrow_mut() += grad * x_val / denom;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 372: `*self.nodes[*x].gradient.borrow_mut() -= grad * y_val / denom;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 528: `let eps = F::from(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 541: `hessian[[i, j]] = (grad_plus[i] - grad_base[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 548: `let avg = (hessian[[i, j]] + hessian[[j, i]]) / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 583: `let eps = F::from(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 609: `jvp[i] = (tape.value(idx_pert) - tape.value(idx_base)) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 698: `let grad = reverse_gradient(f, x.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 716: `let jac = reverse_jacobian(f, x.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### autodiff/sensitivity.rs

53 issues found:

- Line 62: `rel_sens[[i, j]] *= sens.nominal_value / y_nominal;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 88: `avg_sens[j] = sum / F::from(n_time).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 153: `.into_shape_with_order((n_states,)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 159: `let eps = F::from(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 168: `df_dy[[i, j]] = (f_pert[i] - f[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 176: `let df_dp = (f_pert - &f) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 249: `param_indices[j] = (s_ij * sens.nominal_value / y_nominal).abs();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 359: `let u = F::from(i).unwrap() / F::from(self.n_samples - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `let n = F::from(self.n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 410: `let y = (y_a[i] + y_b[i]) / F::from(2.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 415: `let mean = sum / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 416: `sum_sq / n - mean * mean`
  - **Fix**: Division without zero check - use safe_divide()
- Line 427: `let n = F::from(self.n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `let v_i = sum / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 435: `(v_i / var_y).max(F::zero()).min(F::one())`
  - **Fix**: Division without zero check - use safe_divide()
- Line 440: `let n = F::from(self.n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 448: `let e_i = sum / (F::from(2.0).unwrap() * n);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `(e_i / var_y).max(F::zero()).min(F::one())`
  - **Fix**: Division without zero check - use safe_divide()
- Line 496: `let omega_max = (self.n_samples - 1) / (2 * self.interference_factor);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 523: `let s = F::from(k).unwrap() / F::from(self.n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 531: `let angle = F::from(2.0 * std::f64::consts::PI * omega as f64).unwrap() * s;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 532: `let x = (F::one() + angle.sin()) / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 537: `let angle = F::from(2.0 * std::f64::consts::PI * omega_j as f64).unwrap() * s;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 538: `let x = (F::one() + angle.sin()) / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 556: `let angle = F::from(2.0 * std::f64::consts::PI * omega as f64 * k as f64 / n as ...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 561: `a_omega *= F::from(2.0).unwrap() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 562: `b_omega *= F::from(2.0).unwrap() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 565: `(a_omega * a_omega + b_omega * b_omega).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 582: `norm = norm.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 611: `if cumulative / total >= threshold {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 651: `a_matrix[[i, j]] = lower + (upper - lower) * F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 661: `b_matrix[[i, j]] = lower + (upper - lower) * F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 723: `let _mean_y = y_a.mean_axis(ndarray::Axis(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 761: `let v_i = sum / F::from(self.n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 762: `s_i[j] = v_i / var_y[j];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 773: `let v_not_i = sum / F::from(self.n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 774: `st_i[j] = F::one() - v_not_i / var_y[j];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 814: `delta: F::from(0.1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 841: `trajectory[[0, j]] = lower + (upper - lower) * F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 891: `let effect = (y_after - y_before) /`
  - **Fix**: Division without zero check - use safe_divide()
- Line 906: `let n = F::from(effects.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 910: `mu[j] = sum_abs / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 913: `let mean: F = effects.iter().fold(F::zero(), |acc, &x| acc + x) / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 916: `.fold(F::zero(), |acc, x| acc + x) / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 917: `sigma[j] = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 966: `let ee = (y2 - y1) / delta;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 969: `let (sum, sum_sq) = effects.get_mut(name).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 977: `let n_traj = F::from(self.n_trajectories).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 981: `let mu = sum / n_traj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 982: `let sigma = ((sum_sq / n_traj) - mu * mu).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 982: `let sigma = ((sum_sq / n_traj) - mu * mu).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 998: `current[i] = low + (high - low) * F::from(0.5).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 1005: `let delta = (high - low) / F::from(self.grid_levels - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### autodiff/sparse.rs

8 issues found:

- Line 57: `1.0 - (self.nnz() as f64 / total)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 370: `.par_chunks(n / scirs2_core::parallel_ops::num_threads().max(1) + 1)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 412: `.par_chunks(self.n_rows / scirs2_core::parallel_ops::num_threads().max(1))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 523: `let deriv = (f_pert[row] - f0[row]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 578: `jac.values[idx] += dy[i] * dx[j] / dx_norm_sq;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 606: `let alpha = F::from(sample).unwrap() / F::from(n_samples - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 711: `let y = jac.apply(x.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 738: `let y = csr.apply(x.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### autotuning.rs

8 issues found:

- Line 226: `let data: Vec<u64> = vec![1; size / 8];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 236: `let bytes_per_second = (size as f64) / duration.as_secs_f64();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 362: `(max_threads / 2).clamp(1, 4)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 365: `max_threads.min(problem_size / 1000)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 372: `let l2_elements = self.hardware.l2_cache_size / 8;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 379: `l1_elements / 4`
  - **Fix**: Division without zero check - use safe_divide()
- Line 382: `l2_elements / 16`
  - **Fix**: Division without zero check - use safe_divide()
- Line 524: `profile.chunk_size = (samples / (hardware.cpu_threads * 8)).max(1000);`
  - **Fix**: Division without zero check - use safe_divide()

### bvp.rs

25 issues found:

- Line 30: `tol: F::from_f64(1e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 34: `rtol: F::from_f64(1e-4).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 35: `atol: F::from_f64(1e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 159: `let h = (b - a) / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 162: `.map(|i| a + F::from_usize(i).unwrap() * h)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 217: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 224: `jac[[j, k]] = (bc_pert[j] - bc_res[j]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 232: `jac[[j, (n_points - 1) * n_dim + k]] = (bc_pert[j] - bc_res[j]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 247: `jac[[equation_idx, var_idx_left]] = -F::one() / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 248: `jac[[equation_idx, var_idx_right]] = F::one() / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 251: `let f_avg = (f_values[i][j] + f_values[i + 1][j]) / F::from_f64(2.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 252: `residuals[equation_idx] = (y[i + 1][j] - y[i][j]) / h - f_avg;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 274: `residual_norm = delta_y.mapv(|v| v.abs()).sum() / F::from_usize(n_variables).unw...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 289: `let error = delta_y_reshaped[i].mapv(|v| v.abs()).sum() / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 296: `let median_idx = error_values.len() / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 307: `if errors[i] > median_error * F::from_f64(2.0).unwrap()`
  - **Fix**: Use .get() with proper bounds checking
- Line 311: `let mid_x = (mesh[i] + mesh[i + 1]) / F::from_f64(2.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 315: `let mid_y = (y[i].clone() + y[i + 1].clone()) / F::from_f64(2.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 392: `if max_val < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `let factor = aug[[j, i]] / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 421: `if aug[[i, n_cols]].abs() > F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `x[i] = sum / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 479: `.map(|i| a + (b - a) * F::from_usize(i).unwrap() / F::from_usize(n_points - 1).u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 492: `let t = F::from_usize(i).unwrap() / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 534: `let n_dirichlet = n_dim / 2;`
  - **Fix**: Division without zero check - use safe_divide()

### bvp_extended.rs

17 issues found:

- Line 192: `.map(|i| a + (b - a) * F::from_usize(i).unwrap() / F::from_usize(n_points - 1).u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 209: `let t = F::from_usize(i).unwrap() / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 392: `let points_per_segment = (n_points - 1) / n_segments + 1;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 406: `let t = F::from_usize(j).unwrap() / F::from_usize(n_seg_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 465: `F::from(1e-6).unwrap(), // Default jacobian epsilon`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 473: `let row = i / n_dim;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 538: `let dydt = (&y_next - &y_prev) / (F::from_f64(2.0).unwrap() * h);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `let dydt_left = (&y_left_next - &y_left) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 593: `let dydt_right = (&y_right - &y_right_prev) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 614: `.position(|&x| (x - interior_x).abs() < F::from_f64(1e-10).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 625: `(&y_next - &y_prev) / (F::from_f64(2.0).unwrap() * h)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 630: `(&y_next - &y_at_point) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 633: `(&y_at_point - &y_prev) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 683: `let row_idx = col / n_dim;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 703: `jacobian[row][col] = (residuals_pert[row] - residuals_base[row]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 768: `if a[[k, k]].abs() < F::from_f64(1e-12).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 776: `let factor = a[[i, k]] / a[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()

### cubature.rs

73 issues found:

- Line 32: `abs_tol: F::from_f64(1.49e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 33: `rel_tol: F::from_f64(1.49e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 84: `let half_pi = F::from_f64(std::f64::consts::FRAC_PI_2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 100: `let half_pi = F::from_f64(std::f64::consts::FRAC_PI_2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 116: `let pi = F::from_f64(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 117: `let half = F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 280: `let error = result.abs() * F::epsilon() * F::from_f64(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 334: `F::from_f64(-0.9491079123427585).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 335: `F::from_f64(-0.7415311855993944).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 336: `F::from_f64(-0.4058451513773972).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 338: `F::from_f64(0.4058451513773972).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 339: `F::from_f64(0.7415311855993944).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 340: `F::from_f64(0.9491079123427585).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 344: `F::from_f64(0.1294849661688697).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `F::from_f64(0.2797053914892766).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 346: `F::from_f64(0.3818300505051189).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 347: `F::from_f64(0.4179591836734694).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 348: `F::from_f64(0.3818300505051189).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 349: `F::from_f64(0.2797053914892766).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 350: `F::from_f64(0.1294849661688697).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 354: `let mid = (a + b) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 355: `let scale = (b - a) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 432: `F::from_f64(-0.9931285991850949).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 433: `F::from_f64(-0.9639719272779138).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `F::from_f64(-0.912_234_428_251_326).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 435: `F::from_f64(-0.8391169718222188).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 436: `F::from_f64(-0.7463319064601508).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `F::from_f64(-0.636_053_680_726_515).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 438: `F::from_f64(-0.5108670019508271).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 439: `F::from_f64(-0.3737060887154195).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 440: `F::from_f64(-0.2277858511416451).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 441: `F::from_f64(-0.0765265211334973).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 442: `F::from_f64(0.0765265211334973).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `F::from_f64(0.2277858511416451).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 444: `F::from_f64(0.3737060887154195).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 445: `F::from_f64(0.5108670019508271).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 446: `F::from_f64(0.636_053_680_726_515).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 447: `F::from_f64(0.7463319064601508).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 448: `F::from_f64(0.8391169718222188).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `F::from_f64(0.912_234_428_251_326).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 450: `F::from_f64(0.9639719272779138).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 451: `F::from_f64(0.9931285991850949).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 455: `F::from_f64(0.0176140071391521).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 456: `F::from_f64(0.0406014298003869).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 457: `F::from_f64(0.0626720483341091).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 458: `F::from_f64(0.0832767415767048).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `F::from_f64(0.1019301198172404).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 460: `F::from_f64(0.1181945319615184).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `F::from_f64(0.1316886384491766).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 462: `F::from_f64(0.142_096_109_318_382).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 463: `F::from_f64(0.1491729864726037).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 464: `F::from_f64(0.1527533871307258).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 465: `F::from_f64(0.1527533871307258).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 466: `F::from_f64(0.1491729864726037).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 467: `F::from_f64(0.142_096_109_318_382).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 468: `F::from_f64(0.1316886384491766).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 469: `F::from_f64(0.1181945319615184).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 470: `F::from_f64(0.1019301198172404).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 471: `F::from_f64(0.0832767415767048).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 472: `F::from_f64(0.0626720483341091).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 473: `F::from_f64(0.0406014298003869).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 474: `F::from_f64(0.0176140071391521).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 485: `F::from_f64(0.4999).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 487: `(Bound::NegInf, Bound::PosInf) => F::from_f64(0.499).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 491: `let offset = F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 577: `let slice = x.as_slice().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 606: `let result = cubature(f, &bounds, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 628: `let result = cubature(f, &bounds, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 639: `let result = nquad(f, &ranges, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 658: `let result = cubature(f, &bounds, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 659: `assert!((result.value - PI.sqrt()).abs() < 1e-3); // Relaxed tolerance for infin...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 677: `let result = cubature(f, &bounds, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 699: `let result = cubature(f, &bounds, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### dae/index_reduction.rs

9 issues found:

- Line 273: `tol: F::from_f64(1e-10).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 565: `constraint_tol: F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 589: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 653: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 671: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 717: `let epsilon = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 734: `let df = (f_plus - f_val.view()) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 759: `let df = (f_plus - f_val.view()) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 817: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation

### dae/methods/bdf_dae.rs

103 issues found:

- Line 48: `span * F::from_f64(0.01).unwrap() // 1% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 54: `span * F::from_f64(1e-6).unwrap() // Very small relative to interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 59: `span * F::from_f64(0.1).unwrap() // 10% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 89: `vec![F::from_f64(-1.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 92: `F::from_f64(-4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 93: `F::from_f64(1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `F::from_f64(-18.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 98: `F::from_f64(9.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 99: `F::from_f64(-2.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 103: `F::from_f64(-48.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 104: `F::from_f64(36.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `F::from_f64(-16.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 106: `F::from_f64(3.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 110: `F::from_f64(-300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 111: `F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 112: `F::from_f64(-200.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 113: `F::from_f64(75.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 114: `F::from_f64(-12.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 120: `F::from_f64(1.0).unwrap(),          // Order 1`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `F::from_f64(2.0 / 3.0).unwrap(),    // Order 2`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `F::from_f64(6.0 / 11.0).unwrap(),   // Order 3`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 123: `F::from_f64(12.0 / 25.0).unwrap(),  // Order 4`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 124: `F::from_f64(60.0 / 137.0).unwrap(), // Order 5`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 164: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 221: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 225: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 227: `let residual_norm = (res_x_norm * res_x_norm + res_g_norm * res_g_norm).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 241: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 248: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 267: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 277: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 336: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 348: `let min_alpha = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 375: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 379: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 382: `(res_x_new_norm * res_x_new_norm + res_g_new_norm * res_g_new_norm).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 392: `alpha_damp *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 398: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 406: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 432: `error_norm_x += (error_x[i] / scale).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 434: `error_norm_x = (error_norm_x / F::from_usize(n_x).unwrap()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 439: `error_norm_y += (error_y[i] / scale).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 441: `error_norm_y = (error_norm_y / F::from_usize(n_y).unwrap()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 448: `let safety = F::from_f64(0.9).unwrap(); // Safety factor`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 452: `h * safety * (F::one() / error_norm).powf(F::one() / F::from_i32(error_order).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `h * F::from_f64(2.0).unwrap() // Double the step size if error is 0`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 458: `let max_increase = F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `let max_decrease = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `let h_new = (h_new / h).max(max_decrease).min(max_increase) * h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 552: `span * F::from_f64(0.01).unwrap() // 1% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 558: `span * F::from_f64(1e-6).unwrap() // Very small relative to interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 563: `span * F::from_f64(0.1).unwrap() // 10% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 585: `vec![F::from_f64(-1.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 588: `F::from_f64(-4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 589: `F::from_f64(1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 593: `F::from_f64(-18.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 594: `F::from_f64(9.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 595: `F::from_f64(-2.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 599: `F::from_f64(-48.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 600: `F::from_f64(36.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 601: `F::from_f64(-16.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 602: `F::from_f64(3.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 606: `F::from_f64(-300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 607: `F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 608: `F::from_f64(-200.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 609: `F::from_f64(75.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 610: `F::from_f64(-12.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 616: `F::from_f64(1.0).unwrap(),          // Order 1`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `F::from_f64(2.0 / 3.0).unwrap(),    // Order 2`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 618: `F::from_f64(6.0 / 11.0).unwrap(),   // Order 3`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 619: `F::from_f64(12.0 / 25.0).unwrap(),  // Order 4`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 620: `F::from_f64(60.0 / 137.0).unwrap(), // Order 5`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 651: `(&y_pred - &y_current) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 703: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 720: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 729: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 742: `let scale = F::one() / (h * beta);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 759: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 767: `let min_alpha = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 805: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 815: `alpha_damp *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 821: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 829: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 854: `error_norm += (error[i] / scale).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 856: `error_norm = (error_norm / F::from_usize(n).unwrap()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 860: `let safety = F::from_f64(0.9).unwrap(); // Safety factor`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 864: `h * safety * (F::one() / error_norm).powf(F::one() / F::from_i32(error_order).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 866: `h * F::from_f64(2.0).unwrap() // Double the step size if error is 0`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 870: `let max_increase = F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 871: `let max_decrease = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 873: `let h_new = (h_new / h).max(max_decrease).min(max_increase) * h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 976: `let t_ratio = h / dt;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 998: `let t_ratio = h / dt_recent;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1001: `let scaling = F::from_f64(1.0 + 0.3 * order_to_use as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1081: `let col_j = (f_perturbed - &f_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1128: `let col_j = (f_perturbed - &f_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1175: `let col_j = (f_perturbed - &f_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1222: `let col_j = (f_perturbed - &f_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1275: `if a_copy[[k, k]].abs() < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1284: `let factor = a_copy[[i, k]] / a_copy[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1293: `if a_copy[[n - 1, n - 1]].abs() < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1301: `x[n - 1] = b_copy[n - 1] / a_copy[[n - 1, n - 1]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1307: `x[i] = (b_copy[i] - sum) / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()

### dae/methods/block_precond.rs

43 issues found:

- Line 199: `if l[[i, k]].abs() > F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 205: `if u[[k, j]].abs() > F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 207: `if l[[i, j]].abs() > F::from_f64(1e-14).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 208: `|| u[[i, j]].abs() > F::from_f64(1e-14).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 222: `if u[[i, i]].abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 223: `u[[i, i]] = F::from_f64(1e-14).unwrap() * u[[i, i]].signum();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 226: `d_scaling[i] = F::one() / u[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 302: `let n_blocks = n / block_size;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 340: `if val.abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 341: `result[[0, 0]] = F::from_f64(1e-14).unwrap() * val.signum();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 343: `result[[0, 0]] = F::one() / val;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 356: `if det.abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 358: `let reg = F::from_f64(1e-14).unwrap() * det.signum();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 359: `result[[0, 0]] = d / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 360: `result[[0, 1]] = -b / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 361: `result[[1, 0]] = -c / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 362: `result[[1, 1]] = a / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 364: `result[[0, 0]] = d / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 365: `result[[0, 1]] = -b / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 366: `result[[1, 0]] = -c / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 367: `result[[1, 1]] = a / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 388: `if det.abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 390: `let reg = F::from_f64(1e-14).unwrap() * det.signum();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 393: `let a11 = (e * i - f * h) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 394: `let a12 = (c * h - b * i) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 395: `let a13 = (b * f - c * e) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 396: `let a21 = (f * g - d * i) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 397: `let a22 = (a * i - c * g) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 398: `let a23 = (c * d - a * f) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 399: `let a31 = (d * h - e * g) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 400: `let a32 = (b * g - a * h) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 401: `let a33 = (a * e - b * d) / (det + reg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 415: `let a11 = (e * i - f * h) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 416: `let a12 = (c * h - b * i) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 417: `let a13 = (b * f - c * e) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 418: `let a21 = (f * g - d * i) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 419: `let a22 = (a * i - c * g) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 420: `let a23 = (c * d - a * f) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 421: `let a31 = (d * h - e * g) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 422: `let a32 = (b * g - a * h) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 423: `let a33 = (a * e - b * d) / det;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 461: `if max_val < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 462: `lu[[p, k]] = F::from_f64(1e-14).unwrap() * lu[[p, k]].signum();`
  - **Fix**: Replace with ? operator or .ok_or()

### dae/methods/krylov_dae.rs

118 issues found:

- Line 70: `span * F::from_f64(0.01).unwrap() // 1% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 76: `span * F::from_f64(1e-6).unwrap() // Very small relative to interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 81: `span * F::from_f64(0.1).unwrap() // 10% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 92: `let gmres_tol = F::from_f64(GMRES_TOL).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 112: `vec![F::from_f64(-1.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 115: `F::from_f64(-4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 116: `F::from_f64(1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 120: `F::from_f64(-18.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `F::from_f64(9.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `F::from_f64(-2.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 126: `F::from_f64(-48.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 127: `F::from_f64(36.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 128: `F::from_f64(-16.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 129: `F::from_f64(3.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `F::from_f64(-300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 135: `F::from_f64(-200.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 136: `F::from_f64(75.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 137: `F::from_f64(-12.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 143: `F::from_f64(1.0).unwrap(),          // Order 1`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 144: `F::from_f64(2.0 / 3.0).unwrap(),    // Order 2`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 145: `F::from_f64(6.0 / 11.0).unwrap(),   // Order 3`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 146: `F::from_f64(12.0 / 25.0).unwrap(),  // Order 4`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 147: `F::from_f64(60.0 / 137.0).unwrap(), // Order 5`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 227: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 231: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 233: `let residual_norm = (res_x_norm * res_x_norm + res_g_norm * res_g_norm).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 247: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 254: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 264: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 271: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 338: `if diag[i].abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Use .get() with proper bounds checking
- Line 339: `diag[i] = F::from_f64(1e-14).unwrap() * diag[i].signum();`
  - **Fix**: Use .get() with proper bounds checking
- Line 341: `diag[i] = F::one() / diag[i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 347: `if diag[n_x + i].abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 348: `diag[n_x + i] = F::from_f64(1e-14).unwrap() * diag[n_x + i].signum();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 350: `diag[n_x + i] = F::one() / diag[n_x + i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 373: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 385: `let min_alpha = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 412: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 416: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 419: `(res_x_new_norm * res_x_new_norm + res_g_new_norm * res_g_new_norm).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 429: `alpha_damp *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 435: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 470: `error_norm_x += (error_x[i] / scale).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 472: `error_norm_x = (error_norm_x / F::from_usize(n_x).unwrap()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `error_norm_y += (error_y[i] / scale).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 479: `error_norm_y = (error_norm_y / F::from_usize(n_y).unwrap()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 486: `let safety = F::from_f64(0.9).unwrap(); // Safety factor`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 490: `h * safety * (F::one() / error_norm).powf(F::one() / F::from_i32(error_order).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 492: `h * F::from_f64(2.0).unwrap() // Double the step size if error is 0`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 496: `let max_increase = F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 497: `let max_decrease = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 499: `let h_new = (h_new / h).max(max_decrease).min(max_increase) * h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 595: `span * F::from_f64(0.01).unwrap() // 1% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 601: `span * F::from_f64(1e-6).unwrap() // Very small relative to interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 606: `span * F::from_f64(0.1).unwrap() // 10% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `let gmres_tol = F::from_f64(GMRES_TOL).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 632: `vec![F::from_f64(-1.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 635: `F::from_f64(-4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 636: `F::from_f64(1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 640: `F::from_f64(-18.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 641: `F::from_f64(9.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 642: `F::from_f64(-2.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 646: `F::from_f64(-48.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 647: `F::from_f64(36.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 648: `F::from_f64(-16.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 649: `F::from_f64(3.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 653: `F::from_f64(-300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 654: `F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 655: `F::from_f64(-200.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 656: `F::from_f64(75.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 657: `F::from_f64(-12.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 663: `F::from_f64(1.0).unwrap(),          // Order 1`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 664: `F::from_f64(2.0 / 3.0).unwrap(),    // Order 2`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 665: `F::from_f64(6.0 / 11.0).unwrap(),   // Order 3`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 666: `F::from_f64(12.0 / 25.0).unwrap(),  // Order 4`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 667: `F::from_f64(60.0 / 137.0).unwrap(), // Order 5`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 698: `(&y_pred - &y_current) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 750: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 765: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 772: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 780: `let scale = F::one() / (h * beta);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 812: `if diag[i].abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Use .get() with proper bounds checking
- Line 813: `diag[i] = F::from_f64(1e-14).unwrap() * diag[i].signum();`
  - **Fix**: Use .get() with proper bounds checking
- Line 815: `diag[i] = F::one() / diag[i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 841: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 849: `let min_alpha = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 887: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 897: `alpha_damp *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 903: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 911: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 937: `error_norm += (error[i] / scale).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 939: `error_norm = (error_norm / F::from_usize(n).unwrap()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 943: `let safety = F::from_f64(0.9).unwrap(); // Safety factor`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 947: `h * safety * (F::one() / error_norm).powf(F::one() / F::from_i32(error_order).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 949: `h * F::from_f64(2.0).unwrap() // Double the step size if error is 0`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 953: `let max_increase = F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 954: `let max_decrease = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 956: `let h_new = (h_new / h).max(max_decrease).min(max_increase) * h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1068: `let r0_norm = r0.iter().fold(F::zero(), |acc, &v| acc + v * v).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1150: `q.push(r0 / r0_norm);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1181: `let w_norm = w.iter().fold(F::zero(), |acc, &val| acc + val * val).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1185: `if w_norm < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1191: `q.push(w / w_norm);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1242: `let t = -a / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1243: `let s = F::one() / (F::one() + t * t).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1243: `let s = F::one() / (F::one() + t * t).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1247: `let t = -b / a;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1248: `let c = F::one() / (F::one() + t * t).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1248: `let c = F::one() / (F::one() + t * t).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1268: `x[i] = (g_vec[i] - sum) / r[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1322: `let scaling = F::from_f64(1.0 + 0.3 * order_to_use as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1402: `let col_j = (f_perturbed - &f_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1449: `let col_j = (f_perturbed - &f_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1496: `let col_j = (f_perturbed - &f_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1543: `let col_j = (f_perturbed - &f_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()

### dae/solvers.rs

61 issues found:

- Line 56: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 57: `let tol = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 113: `let g_x = compute_jacobian_x(&g_closure, t, x, y, F::from_f64(1e-8).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 117: `let dt = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 119: `let g_t = (g_t_plus - g_val.clone()) / dt;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 245: `let column = (g_plus - &g_base) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 309: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 310: `let tol = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 343: `span * F::from_f64(0.01).unwrap() // 1% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 349: `span * F::from_f64(1e-6).unwrap() // Very small relative to interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 354: `span * F::from_f64(0.1).unwrap() // 10% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 369: `F::from_f64(4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 370: `-F::from_f64(1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 374: `F::from_f64(18.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 375: `-F::from_f64(9.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 376: `F::from_f64(2.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 380: `F::from_f64(48.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 381: `-F::from_f64(36.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 382: `F::from_f64(16.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 383: `-F::from_f64(3.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 387: `F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 388: `-F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 389: `F::from_f64(200.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 390: `-F::from_f64(75.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 391: `F::from_f64(12.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 447: `let step_ratio = h / (t_current - t_values[step - 1]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 462: `let step_ratio = h / (t_current - t_values[step - 1]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 478: `let y_prime_bdf = (&y_pred - &y_current) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 498: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 518: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 526: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 537: `let scale = F::one() / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 548: `2 => F::from_f64(4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 549: `3 => F::from_f64(18.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 550: `4 => F::from_f64(48.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 551: `5 => F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 555: `let scale = bdf_coeff / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 581: `let min_alpha = F::from_f64(0.1).unwrap(); // Don't reduce step size too much`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 590: `(&y_new - &y_current) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 598: `F::from_f64(4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 599: `-F::from_f64(1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 603: `F::from_f64(18.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 604: `-F::from_f64(9.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 605: `F::from_f64(2.0 / 11.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 609: `F::from_f64(48.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 610: `-F::from_f64(36.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 611: `F::from_f64(16.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 612: `-F::from_f64(3.0 / 25.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 616: `F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `-F::from_f64(300.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 618: `F::from_f64(200.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 619: `-F::from_f64(75.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 620: `F::from_f64(12.0 / 137.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 637: `bdf_derivative / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 647: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 657: `alpha *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 687: `h = (h * F::from_f64(1.1).unwrap()).min(max_step);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 693: `h = (h * F::from_f64(0.5).unwrap()).max(min_step);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 894: `opts.max_step = Some(max_step * F::from_f64(0.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 898: `opts.rtol *= F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 899: `opts.atol *= F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### dae/types.rs

3 issues found:

- Line 84: `rtol: F::from_f64(1e-3).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `atol: F::from_f64(1e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 91: `newton_tol: F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()

### dae/utils/linear_solvers.rs

8 issues found:

- Line 61: `if max_val < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 84: `let factor = a_copy[[i, k]] / a_copy[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 108: `x[i] = sum / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 162: `if max_val < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 200: `if u[[k, k]].abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 236: `if u[[i, i]].abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 267: `sum.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 285: `sum.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation

### dae/utils/mod.rs

6 issues found:

- Line 24: `let epsilon = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 39: `jacobian[(j, i)] = (g_perturbed[j] - g0[j]) / epsilon;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 50: `jacobian[(j, n + i)] = (g_perturbed[j] - g0[j]) / epsilon;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 66: `return matrix[(0, 0)].abs() < F::from_f64(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 71: `let epsilon = F::from_f64(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 83: `if diagonal < epsilon || diagonal < off_diagonal_sum * F::from_f64(0.1).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()

### gaussian.rs

81 issues found:

- Line 79: `weights: Array1::from_vec(vec![F::from_f64(2.0).unwrap()]),`
  - **Fix**: Handle array creation errors properly
- Line 87: `F::from_f64(-0.5773502691896257).unwrap(), // -1/sqrt(3)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 88: `F::from_f64(0.5773502691896257).unwrap(),  // 1/sqrt(3)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 91: `let weights = vec![F::from_f64(1.0).unwrap(), F::from_f64(1.0).unwrap()];`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 103: `F::from_f64(-0.7745966692414834).unwrap(), // -sqrt(3/5)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `F::from_f64(0.7745966692414834).unwrap(), // sqrt(3/5)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 109: `F::from_f64(5.0 / 9.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 110: `F::from_f64(8.0 / 9.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 111: `F::from_f64(5.0 / 9.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 124: `F::from_f64(-0.8611363115940526).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 125: `F::from_f64(-0.3399810435848563).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 126: `F::from_f64(0.3399810435848563).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 127: `F::from_f64(0.8611363115940526).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 131: `F::from_f64(0.3478548451374538).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 132: `F::from_f64(0.6521451548625461).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `F::from_f64(0.6521451548625461).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `F::from_f64(0.3478548451374538).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 147: `F::from_f64(-0.906_179_845_938_664).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 148: `F::from_f64(-0.538_469_310_105_683).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 150: `F::from_f64(0.538_469_310_105_683).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 151: `F::from_f64(0.906_179_845_938_664).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 155: `F::from_f64(0.2369268850561891).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 156: `F::from_f64(0.4786286704993665).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 157: `F::from_f64(0.5688888888888889).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 158: `F::from_f64(0.4786286704993665).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 159: `F::from_f64(0.2369268850561891).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 172: `F::from_f64(-0.9739065285171717).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 173: `F::from_f64(-0.8650633666889845).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 174: `F::from_f64(-0.6794095682990244).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 175: `F::from_f64(-0.4333953941292472).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 176: `F::from_f64(-0.1488743389816312).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 177: `F::from_f64(0.1488743389816312).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 178: `F::from_f64(0.4333953941292472).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 179: `F::from_f64(0.6794095682990244).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 180: `F::from_f64(0.8650633666889845).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 181: `F::from_f64(0.9739065285171717).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 185: `F::from_f64(0.0666713443086881).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 186: `F::from_f64(0.1494513491505806).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 187: `F::from_f64(0.219_086_362_515_982).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 188: `F::from_f64(0.2692667193099963).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 189: `F::from_f64(0.2955242247147529).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 190: `F::from_f64(0.2955242247147529).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 191: `F::from_f64(0.2692667193099963).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 192: `F::from_f64(0.219_086_362_515_982).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 193: `F::from_f64(0.1494513491505806).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 194: `F::from_f64(0.0666713443086881).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 230: `let mid = (a + b) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 231: `let half_length = (b - a) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 340: `let mid = (a + b) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 341: `let half_length = (b - a) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 433: `let half_length = (b - a) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `let center = (a + b) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `result_kronrod += F::from_f64(wgk[7]).unwrap() * fc;`
  - **Fix**: Use .get() with proper bounds checking
- Line 447: `let x = F::from_f64(xgk[i]).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 450: `result_kronrod += F::from_f64(wgk[i]).unwrap() * fval;`
  - **Fix**: Use .get() with proper bounds checking
- Line 451: `result_gauss += F::from_f64(wg[i]).unwrap() * fval;`
  - **Fix**: Use .get() with proper bounds checking
- Line 455: `result_kronrod += F::from_f64(wgk[14 - i]).unwrap() * fval;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 456: `result_gauss += F::from_f64(wg[6 - i]).unwrap() * fval;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `let x = F::from_f64(xgk[i]).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 464: `result_kronrod += F::from_f64(wgk[i]).unwrap() * fval;`
  - **Fix**: Use .get() with proper bounds checking
- Line 468: `result_kronrod += F::from_f64(wgk[i]).unwrap() * fval;`
  - **Fix**: Use .get() with proper bounds checking
- Line 557: `let half_length = (b - a) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 558: `let center = (a + b) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 565: `result_kronrod += F::from_f64(wgk[10]).unwrap() * fc;`
  - **Fix**: Use .get() with proper bounds checking
- Line 569: `let x = F::from_f64(xgk[i]).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 572: `result_kronrod += F::from_f64(wgk[i]).unwrap() * fval;`
  - **Fix**: Use .get() with proper bounds checking
- Line 576: `result_kronrod += F::from_f64(wgk[20 - i]).unwrap() * fval;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 580: `let idx = i / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 581: `result_gauss += F::from_f64(wg[idx]).unwrap() * fval;`
  - **Fix**: Use .get() with proper bounds checking
- Line 582: `result_gauss += F::from_f64(wg[9 - idx]).unwrap() * fval;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 606: `let quad5 = GaussLegendreQuadrature::<f64>::new(5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 610: `assert_relative_eq!(result, 1.0 / 3.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 613: `let quad10 = GaussLegendreQuadrature::<f64>::new(10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 619: `let quad10 = GaussLegendreQuadrature::<f64>::new(10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 621: `let exact = PI.sqrt() * libm::erf(1.0);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 628: `let result = gauss_legendre(|x| x * x, 0.0, 1.0, 5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 631: `assert_relative_eq!(result, 1.0 / 3.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 640: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 643: `assert_relative_eq!(result, 2.0 / 3.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 652: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 655: `assert_relative_eq!(result, 1.0 / 27.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()

### geometric/lie_group.rs

67 issues found:

- Line 116: `half_xi *= self.dt / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 139: `let mut avg_xi = (xi1.to_vector() + xi2.to_vector()) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 154: `let mut exp_arg = k1.to_vector() * (self.dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 160: `exp_arg = k2.to_vector() * (self.dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 172: `let combined = (k1.to_vector() + k2.to_vector() * 2.0 + k3.to_vector() * 2.0 + k...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 177: `final_xi = final_xi + comm.to_vector() * (self.dt * self.dt / 12.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 190: `let b1 = 1.0 / 6.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 191: `let b2 = 2.0 / 3.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 192: `let b3 = 1.0 / 6.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 247: `self.omega.dot(&self.omega).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 285: `let k = algebra.to_matrix() / theta;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 297: `let theta = ((trace - 1.0) / 2.0).clamp(-1.0, 1.0).acos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 306: `]) / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 310: `let factor = theta / (2.0 * theta.sin());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 410: `inv[[0, 0]] = (inertia[[1, 1]] * inertia[[2, 2]] - inertia[[1, 2]] * inertia[[2,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 411: `inv[[0, 1]] = (inertia[[0, 2]] * inertia[[2, 1]] - inertia[[0, 1]] * inertia[[2,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 412: `inv[[0, 2]] = (inertia[[0, 1]] * inertia[[1, 2]] - inertia[[0, 2]] * inertia[[1,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 413: `inv[[1, 0]] = (inertia[[1, 2]] * inertia[[2, 0]] - inertia[[1, 0]] * inertia[[2,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 414: `inv[[1, 1]] = (inertia[[0, 0]] * inertia[[2, 2]] - inertia[[0, 2]] * inertia[[2,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 415: `inv[[1, 2]] = (inertia[[0, 2]] * inertia[[1, 0]] - inertia[[0, 0]] * inertia[[1,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 416: `inv[[2, 0]] = (inertia[[1, 0]] * inertia[[2, 1]] - inertia[[1, 1]] * inertia[[2,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 417: `inv[[2, 1]] = (inertia[[0, 1]] * inertia[[2, 0]] - inertia[[0, 0]] * inertia[[2,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 418: `inv[[2, 2]] = (inertia[[0, 0]] * inertia[[1, 1]] - inertia[[0, 1]] * inertia[[1,...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 467: `(self.v.dot(&self.v) + self.omega.dot(&self.omega)).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 494: `let omega_norm = algebra.omega.dot(&algebra.omega).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 502: `let axis = &algebra.omega / omega_norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 507: `+ axis_cross * ((1.0 - omega_norm.cos()) / omega_norm)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 508: `+ axis_cross2 * ((omega_norm - omega_norm.sin()) / omega_norm);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 520: `let omega_algebra = self.rotation.log();`
  - **Fix**: Mathematical operation .log() without validation
- Line 522: `let omega_norm = omega.dot(omega).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 529: `let axis = omega / omega_norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 533: `let cot_half = 1.0 / (omega_norm / 2.0).tan();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 535: `- axis_cross / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 536: `+ axis_cross2 * (1.0 / omega_norm.powi(2)) * (1.0 - omega_norm / 2.0 * cot_half)...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 601: `let linear_accel = forces / mass;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 687: `(self.matrix[[1, 0]] + self.matrix[[0, 1]]) / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 688: `(self.matrix[[1, 0]] - self.matrix[[0, 1]]) / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 707: `self.matrix.iter().map(|&x| x * x).sum::<f64>().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 732: `let a_scaled = a / 2.0f64.powi(s);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 741: `u = u + &a2 * (1.0 / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 742: `u = u + &a4 * (1.0 / 24.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 743: `u = u + &a6 * (1.0 / 720.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 747: `v = v + &a2 * (1.0 / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 748: `v = v - &a4 * (1.0 / 24.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 749: `v = v + &a6 * (1.0 / 720.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 779: `log_m = log_m - &a_power / (k as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 781: `log_m = log_m + &a_power / (k as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 849: `let factor = aug[[i, k]] / aug[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 864: `result[[i, j]] = sum / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 928: `let expected_size = n * n + n * (n + 1) / 2 + n * (n + 1) / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 935: `let n_float = (-1.0 + (1.0 + 8.0 * len).sqrt()) / 4.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 935: `let n_float = (-1.0 + (1.0 + 8.0 * len).sqrt()) / 4.0;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1039: `self.matrix.iter().map(|&x| x * x).sum::<f64>().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1081: `(self.p * self.p + self.q * self.q + self.z * self.z).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1105: `z: algebra.z + algebra.p * algebra.q / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1114: `z: self.z - self.p * self.q / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1223: `let n = (v.len() as f64).sqrt() as usize;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1224: `let matrix = Array2::from_shape_vec((n, n), v.to_vec()).unwrap();`
  - **Fix**: Handle array creation errors properly
- Line 1229: `Array1::from_vec(self.matrix.as_slice().unwrap().to_vec())`
  - **Fix**: Handle array creation errors properly
- Line 1233: `self.matrix.iter().map(|&x| x * x).sum::<f64>().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1244: `term = term.dot(a) / (k as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1266: `result = result + &term / (k as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1268: `result = result - &term / (k as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1292: `let algebra_recovered = group.log();`
  - **Fix**: Mathematical operation .log() without validation
- Line 1311: `]).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1324: `).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1327: `let (_, final_omega) = &states.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### geometric/structure_preserving.rs

40 issues found:

- Line 84: `let error = (i1 - i0).abs() / (1.0 + i0.abs());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 127: `grad_q[i] = ((self.hamiltonian)(&q_plus.view(), p) - (self.hamiltonian)(&q_minus...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 133: `grad_p[i] = ((self.hamiltonian)(q, &p_plus.view()) - (self.hamiltonian)(q, &p_mi...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 137: `let q_mid = q + &grad_p * (dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 138: `let p_mid = p - &grad_q * (dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 150: `- (self.hamiltonian)(&q_minus.view(), &p_mid.view())) / (2.0 * h);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 157: `- (self.hamiltonian)(&q_mid.view(), &p_minus.view())) / (2.0 * h);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 195: `- (self.hamiltonian)(&q_minus.view(), &p_s.view()) / (2.0 * h);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 203: `- (self.hamiltonian)(&q_s.view(), &p_minus.view()) / (2.0 * h);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 249: `let f_corrected = &f - total_force / self.dim as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 252: `let a = &f_corrected / &self.mass;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 253: `let x_new = x + v * dt + &a * (dt * dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 256: `let f_new_corrected = &f_new - f_new.sum() / self.dim as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 257: `let a_new = &f_new_corrected / &self.mass;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 259: `let v_new = v + (&a + &a_new) * (dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 264: `let a = &f / &self.mass;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 265: `let x_new = x + v * dt + &a * (dt * dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 268: `let a_new = &f_new / &self.mass;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 270: `let v_new = v + (&a + &a_new) * (dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 340: `max_deviation / (1.0 + initial.abs())`
  - **Fix**: Division without zero check - use safe_divide()
- Line 379: `let x1 = 1.0 / (2.0 - 2.0_f64.powf(1.0/3.0));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 379: `let x1 = 1.0 / (2.0 - 2.0_f64.powf(1.0/3.0));`
  - **Fix**: Mathematical operation .powf( without validation
- Line 380: `let x0 = -2.0_f64.powf(1.0/3.0) * x1;`
  - **Fix**: Mathematical operation .powf( without validation
- Line 435: `grad[i] = ((self.kinetic)(&p_plus.view()) - (self.kinetic)(&p_minus.view())) / (...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 452: `grad[i] = ((self.potential)(&q_plus.view()) - (self.potential)(&q_minus.view()))...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 497: `let f_avg = (&f0 + &f1) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 500: `let a_alg = &f_avg / &self.mass;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 503: `let u_new = u + v * dt + &a_alg * (dt * dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 509: `let v_corrected = &v_new - momentum_error / self.mass.sum();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 619: `let factor = a_copy[[j, i]] / pivot;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 633: `x[i] = sum / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 683: `let z_avg = (&z.row(i-1) + &z.row(i) + z_new.row(i-1) + z_new.row(i)) / 4.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 690: `let z_t = (&z_new.row(i) - &z.row(i) + z_new.row(i-1) - z.row(i-1)) / (2.0 * dt)...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 691: `let z_x = (&z_new.row(i) + &z.row(i) - z_new.row(i-1) - z.row(i-1)) / (2.0 * dx)...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 766: `let n = x.len() / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 798: `p[0] * p[0] / (2.0 * m) + k * q[0] * q[0] / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 815: `let (q_new, p_new) = integrator.discrete_gradient_step(&q.view(), &p.view(), dt)...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 832: `let r = (dx * dx + dy * dy).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 833: `let f = if r > 0.0 { 1.0 / r } else { 0.0 };`
  - **Fix**: Division without zero check - use safe_divide()
- Line 851: `let (x1, v1) = integrator.step(&x0.view(), &v0.view(), 0.01).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### geometric/volume_preserving.rs

33 issues found:

- Line 38: `div += (f_plus[i] - f_minus[i]) / (2.0 * h);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 109: `let x_mid = x + &f0 * (self.dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 110: `let f_mid = flow.evaluate(&x_mid.view(), t + self.dt / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 121: `let t_mid = t + self.dt / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 125: `let x_mid = (x + &x_new) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 171: `let gamma = 1.0 / (2.0 - 2.0_f64.powf(1.0 / 3.0));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 171: `let gamma = 1.0 / (2.0 - 2.0_f64.powf(1.0 / 3.0));`
  - **Fix**: Mathematical operation .powf( without validation
- Line 172: `let c1 = gamma / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 173: `let c2 = (1.0 - gamma) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 178: `let d2 = -gamma * 2.0_f64.powf(1.0 / 3.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 178: `let d2 = -gamma * 2.0_f64.powf(1.0 / 3.0);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 233: `let n_steps = ((t_final - t0) / self.dt).ceil() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 357: `let u = (self.psi(x, y + h, t) - self.psi(x, y - h, t)) / (2.0 * h);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 360: `let v = -(self.psi(x + h, y, t) - self.psi(x - h, y, t)) / (2.0 * h);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 376: `-self.alpha.ln() * y.cos() + self.alpha * (self.k * x).cos() * y.sin()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 435: `let n = self.dim / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 447: `grad_h[i] = ((self.hamiltonian)(&x_plus.view()) - (self.hamiltonian)(&x_minus.vi...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 486: `let x_mid = (x + &x_new) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 487: `let div = flow.verify_divergence_free(&x_mid.view(), t + self.base.dt / 2.0, 1e-...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 493: `let corrected = &x_new * (1.0 + correction / n as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 531: `let v = (x1 - x0) / self.dt;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 547: `vec![0.5 - 0.5 / 3.0_f64.sqrt(), 0.5 + 0.5 / 3.0_f64.sqrt()]`
  - **Fix**: Division without zero check - use safe_divide()
- Line 547: `vec![0.5 - 0.5 / 3.0_f64.sqrt(), 0.5 + 0.5 / 3.0_f64.sqrt()]`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 552: `0.5 - 0.5 * (0.6_f64).sqrt(),`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 554: `0.5 + 0.5 * (0.6_f64).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 603: `let g_avg = (&g0 + &g1) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 607: `let correction = (h1 - h0 - g_avg.dot(&dx)) / dx.dot(&dx) * &dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 626: `grad[i] = (h(&x_plus.view()) - h(&x_minus.view())) / (2.0 * eps);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 659: `let (_, x_final) = trajectory.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 667: `Ok((final_volume - initial_volume).abs() / initial_volume)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 719: `).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 726: `let flow = ABCFlow { a: 1.0, b: SQRT_2, c: PI / 2.0 };`
  - **Fix**: Division without zero check - use safe_divide()
- Line 741: `let x1 = integrator.step(&x0.view(), 0.0, &flow).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### lebedev.rs

85 issues found:

- Line 192: `let four_pi = F::from(4.0 * PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 215: `let weight = F::from(0.1666666666666667).unwrap(); // 1/6`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 222: `points[[i, j]] = F::from(points_data[i][j]).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 257: `let w1 = F::from(0.04761904761904762).unwrap(); // 1/21`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 263: `let a = F::from(1.0 / 3.0_f64.sqrt()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 274: `let w2 = F::from(0.038_095_238_095_238_1).unwrap(); // 2/52.5`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 280: `let b = F::from(1.0 / 2.0_f64.sqrt()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 291: `let w3 = F::from(0.03214285714285714).unwrap(); // 9/280`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 339: `let w1 = F::from(0.0166666666666667).unwrap(); // 1/60`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `let a = F::one() / F::from(2.0).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 356: `let w2 = F::from(0.025).unwrap(); // 1/40`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 362: `let a = F::from(0.577_350_269_189_625_7).unwrap(); // 1/sqrt(3)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 373: `let w3 = F::from(0.025).unwrap(); // 1/40`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 380: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 381: `let b = F::one() / F::from(2.0).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 388: `let norm = (s1 * s1 + s2 * s2 + s3 * s3).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 389: `points.push([s1 / norm, s2 / norm, s3 / norm]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 390: `points.push([s1 / norm, s3 / norm, s2 / norm]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 391: `points.push([s3 / norm, s1 / norm, s2 / norm]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 397: `let w4 = F::from(0.0166666666666667).unwrap(); // 1/60`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `let beta = (1.0 - alpha * alpha).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 440: `F::from(a).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 441: `F::from(b).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 442: `F::from(c).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `let phi = (1.0 + 5.0_f64.sqrt()) / 2.0; // Golden ratio`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 450: `let alpha = 0.8 / (1.0 + phi * phi).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 450: `let alpha = 0.8 / (1.0 + phi * phi).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 457: `F::from(0.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 458: `F::from(sign1 * alpha).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `F::from(sign2 * beta).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 462: `F::from(sign1 * alpha).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 463: `F::from(sign2 * beta).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 464: `F::from(0.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 467: `F::from(sign1 * beta).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 468: `F::from(0.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 469: `F::from(sign2 * alpha).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `let norm = (point[0].to_f64().unwrap().powi(2)`
  - **Fix**: Use .get() with proper bounds checking
- Line 478: `+ point[1].to_f64().unwrap().powi(2)`
  - **Fix**: Use .get() with proper bounds checking
- Line 479: `+ point[2].to_f64().unwrap().powi(2))`
  - **Fix**: Use .get() with proper bounds checking
- Line 480: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 483: `*p = F::from(p.to_f64().unwrap() / norm).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 516: `let rescale = F::from(0.65).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 525: `let new_weight = F::from((1.0 - rescale.to_f64().unwrap()) / n_additional as f64...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 554: `let phi = (1.0 + 5.0_f64.sqrt()) / 2.0; // Golden ratio`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 560: `let norm = (a * a + b * b + c * c).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 561: `let a = a / norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 562: `let b = b / norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 563: `let c = c / norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 569: `F::from(sign1 * a).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 570: `F::from(sign2 * b).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 571: `F::from(sign3 * c).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 574: `F::from(sign1 * b).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 575: `F::from(sign2 * c).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 576: `F::from(sign3 * a).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 579: `F::from(sign1 * c).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 580: `F::from(sign2 * a).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 581: `F::from(sign3 * b).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 593: `let norm = (a * a + b * b + c * c).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 594: `let a = a / norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 595: `let b = b / norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 596: `let c = c / norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 602: `F::from(sign1 * a).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 603: `F::from(sign2 * b).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 604: `F::from(sign3 * c).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 607: `F::from(sign1 * b).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 608: `F::from(sign2 * c).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 609: `F::from(sign3 * a).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 612: `F::from(sign1 * c).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 613: `F::from(sign2 * a).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 614: `F::from(sign3 * b).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 649: `let rescale = F::from(0.6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 658: `let new_weight = F::from((1.0 - rescale.to_f64().unwrap()) / n_additional as f64...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 679: `let rule = lebedev_rule::<f64>(LebedevOrder::Order6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 701: `let rule = lebedev_rule::<f64>(LebedevOrder::Order14).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 735: `let result = lebedev_integrate(|_, _, _| 1.0, order).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 761: `let result = lebedev_integrate(|_, _, _: f64| 1.0, order).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 775: `let result = lebedev_integrate(|_, _, z: f64| z, order).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 786: `let result = lebedev_integrate(|x, y, z: f64| x * x + y * y + z * z, order).unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 807: `let expected = 4.0 * PI / 3.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 810: `let result_x = lebedev_integrate(|x: f64, _, _| x * x, order).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 811: `let result_y = lebedev_integrate(|_, y: f64, _| y * y, order).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 812: `let result_z = lebedev_integrate(|_, _, z: f64| z * z, order).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 825: `lebedev_integrate(|x: f64, y: f64, z: f64| x * x + y * y + z * z, order).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 833: `let rule = lebedev_rule::<f32>(LebedevOrder::Order6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 837: `let result = lebedev_integrate(|_, _, _| 1.0_f32, LebedevOrder::Order6).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()

### memory.rs

7 issues found:

- Line 138: `self.buffer.as_ref().unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 143: `self.buffer.as_mut().unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 148: `self.buffer.take().unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 153: `self.buffer.as_ref().unwrap().len()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 158: `self.buffer.as_ref().unwrap().is_empty()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 231: `let block_row = row / block_size;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 232: `let block_col = col / block_size;`
  - **Fix**: Division without zero check - use safe_divide()

### monte_carlo.rs

30 issues found:

- Line 141: `.map(|&(a, b)| Uniform::new_inclusive(a, b).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 161: `for _ in 0..(n_actual_samples / 2) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 195: `let mean = sum / F::from_usize(n_actual_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 202: `let variance = (sum_sq - sum * sum / F::from_usize(n_actual_samples).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 203: `/ F::from_usize(n_actual_samples - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 205: `(variance / F::from_usize(n_actual_samples).unwrap()).sqrt() * volume`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 213: `let variance = (sum_sq - sum * sum / F::from_usize(n_actual_samples).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 214: `/ F::from_usize(n_actual_samples - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 216: `(variance / F::from_usize(n_actual_samples).unwrap()).sqrt() * volume`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 347: `if gx <= F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 357: `let ratio = fx / gx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 378: `let valid_samples_f = F::from_usize(valid_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `let mean = sum / valid_samples_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 383: `(sum_sq - sum * sum / valid_samples_f) / F::from_usize(valid_samples - 1).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 389: `let std_error = (variance / valid_samples_f).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 389: `let std_error = (variance / valid_samples_f).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 494: `let result = monte_carlo(|x| x[0] * x[0], &[(0.0, 1.0)], Some(options)).unwrap()...`
  - **Fix**: Use .get() with proper bounds checking
- Line 497: `assert!(is_close_enough(result.value, 1.0 / 3.0, 0.01));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 515: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 517: `assert!(is_close_enough(result.value, 2.0 / 3.0, 0.01));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 531: `let result = monte_carlo(|x| x[0] * x[0], &[(0.0, 1.0)], Some(options)).unwrap()...`
  - **Fix**: Use .get() with proper bounds checking
- Line 533: `assert!(is_close_enough(result.value, 1.0 / 3.0, 0.01));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 549: `let normal = rand_distr::Normal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 574: `let density = (-0.5 * z * z).exp() / (2.0 * PI).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 574: `let density = (-0.5 * z * z).exp() / (2.0 * PI).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 595: `let exact_value = (PI).sqrt() / 2.0 * libm::erf(3.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 595: `let exact_value = (PI).sqrt() / 2.0 * libm::erf(3.0);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 604: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 625: `let result = monte_carlo_parallel(f, &ranges, Some(options), Some(2)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 628: `assert!(is_close_enough(result.value, 1.0 / 3.0, 0.1));`
  - **Fix**: Division without zero check - use safe_divide()

### monte_carlo_parallel.rs

31 issues found:

- Line 208: `.map(|&(a, b)| Uniform::new_inclusive(a, b).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 218: `for _ in 0..(chunk.len() / 2) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 286: `opts.n_samples / 2 * 2`
  - **Fix**: Division without zero check - use safe_divide()
- Line 323: `.map(|&(a, b)| Uniform::new_inclusive(a, b).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 332: `for _ in 0..(batch_samples / 2) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 365: `let mut sum = shared_sum.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 369: `let mut sum_sq = shared_sum_sq.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 373: `let mut n_evals = shared_n_evals.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `let total_sum = *shared_sum.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 380: `let total_sum_sq = *shared_sum_sq.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 381: `let total_n_evals = *shared_n_evals.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 400: `let mean = sum / F::from_usize(n_evals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `let variance = (sum_sq - sum * sum / F::from_usize(n_evals).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 406: `/ F::from_usize(n_evals - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 408: `(variance / F::from_usize(n_evals).unwrap()).sqrt() * volume`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 413: `let variance = (sum_sq - sum * sum / F::from_usize(n_evals).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 414: `/ F::from_usize(n_evals - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 416: `(variance / F::from_usize(n_evals).unwrap()).sqrt() * volume`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 468: `let combined_value = (result.value * F::from_usize(result.n_evals).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 469: `+ additional_result.value * F::from_usize(additional_result.n_evals).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 470: `/ F::from_usize(total_evals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 474: `(result.std_error * result.std_error * F::from_usize(result.n_evals).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `* F::from_usize(additional_result.n_evals).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 478: `/ F::from_usize(total_evals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 479: `let combined_std_error = combined_error.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 561: `let result = parallel_monte_carlo(f, &ranges, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `let result = parallel_monte_carlo(f, &ranges, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 605: `let result = parallel_monte_carlo(f, &ranges, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 608: `assert_relative_eq!(result.value, 1.0 / 3.0, epsilon = 0.02);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 655: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 662: `assert_relative_eq!(result.value, 2.0 / std::f64::consts::PI, epsilon = 0.05);`
  - **Fix**: Division without zero check - use safe_divide()

### newton_cotes.rs

89 issues found:

- Line 107: `let a = a.unwrap_or_else(|| F::from(0.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 108: `let b = b.unwrap_or_else(|| F::from(1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `let step = (b - a) / F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 124: `points[i] = a + F::from(i).unwrap() * step;`
  - **Fix**: Use .get() with proper bounds checking
- Line 132: `let step = (b - a) / F::from(n + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 135: `points[i] = a + F::from(i + 1).unwrap() * step;`
  - **Fix**: Use .get() with proper bounds checking
- Line 187: `w[0] = F::from(0.5).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 188: `w[1] = F::from(0.5).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 194: `w[0] = F::from(1.0 / 6.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 195: `w[1] = F::from(4.0 / 6.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 196: `w[2] = F::from(1.0 / 6.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 202: `w[0] = F::from(1.0 / 8.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 203: `w[1] = F::from(3.0 / 8.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 204: `w[2] = F::from(3.0 / 8.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 205: `w[3] = F::from(1.0 / 8.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 211: `w[0] = F::from(7.0 / 90.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 212: `w[1] = F::from(32.0 / 90.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 213: `w[2] = F::from(12.0 / 90.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 214: `w[3] = F::from(32.0 / 90.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 215: `w[4] = F::from(7.0 / 90.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 221: `w[0] = F::from(19.0 / 288.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 222: `w[1] = F::from(75.0 / 288.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 223: `w[2] = F::from(50.0 / 288.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 224: `w[3] = F::from(50.0 / 288.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 225: `w[4] = F::from(75.0 / 288.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 226: `w[5] = F::from(19.0 / 288.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 232: `w[0] = F::from(41.0 / 840.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 233: `w[1] = F::from(216.0 / 840.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 234: `w[2] = F::from(27.0 / 840.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 235: `w[3] = F::from(272.0 / 840.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 236: `w[4] = F::from(27.0 / 840.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 237: `w[5] = F::from(216.0 / 840.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 238: `w[6] = F::from(41.0 / 840.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 244: `w[0] = F::from(751.0 / 17280.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 245: `w[1] = F::from(3577.0 / 17280.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 246: `w[2] = F::from(1323.0 / 17280.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 247: `w[3] = F::from(2989.0 / 17280.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 248: `w[4] = F::from(2989.0 / 17280.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 249: `w[5] = F::from(1323.0 / 17280.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 250: `w[6] = F::from(3577.0 / 17280.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 251: `w[7] = F::from(751.0 / 17280.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 266: `w[0] = F::from(2.0 / 3.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 267: `w[1] = F::from(-1.0 / 3.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 268: `w[2] = F::from(2.0 / 3.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 274: `w[0] = F::from(11.0 / 24.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 275: `w[1] = F::from(1.0 / 24.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 276: `w[2] = F::from(1.0 / 24.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 277: `w[3] = F::from(11.0 / 24.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 283: `w[0] = F::from(11.0 / 20.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 284: `w[1] = F::from(-14.0 / 20.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 285: `w[2] = F::from(26.0 / 20.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 286: `w[3] = F::from(-14.0 / 20.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 287: `w[4] = F::from(11.0 / 20.0).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 314: `let step = F::one() / F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 317: `pts[i] = F::from(i).unwrap() * step;`
  - **Fix**: Use .get() with proper bounds checking
- Line 325: `let step = F::one() / F::from(n + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 328: `pts[i] = F::from(i + 1).unwrap() * step;`
  - **Fix**: Use .get() with proper bounds checking
- Line 362: `let contribution_f64 = sign.to_f64().unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 363: `* (1.0 / ((n_f64 + 1.0) * factorial.to_f64().unwrap() * diff.to_f64().unwrap()))...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 364: `let contribution = F::from(contribution_f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 369: `factorial *= F::from(j + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 380: `weights = weights.mapv(|w| w / weight_sum);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 400: `1 => Ok(F::from(-1.0 / 2.0).unwrap()),   // Midpoint rule`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 401: `2 => Ok(F::from(-1.0 / 12.0).unwrap()),  // Trapezoidal rule`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 402: `3 => Ok(F::from(-1.0 / 90.0).unwrap()),  // Simpson's rule`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 403: `4 => Ok(F::from(-3.0 / 80.0).unwrap()),  // Simpson's 3/8 rule`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 404: `5 => Ok(F::from(-8.0 / 945.0).unwrap()), // Boole's rule`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `6 => Ok(F::from(-275.0 / 12096.0).unwrap()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 406: `7 => Ok(F::from(-9.0 / 1400.0).unwrap()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 407: `8 => Ok(F::from(-8183.0 / 518400.0).unwrap()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 413: `/ ((degree + 2) as f64 * (degree + 3) as f64),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 415: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 422: `3 => Ok(F::from(1.0 / 4.0).unwrap()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 423: `4 => Ok(F::from(-3.0 / 20.0).unwrap()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 424: `5 => Ok(F::from(13.0 / 42.0).unwrap()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 430: `/ ((degree + 1) as f64 * (degree + 2) as f64),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 432: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 495: `let result = newton_cotes::<f64>(2, NewtonCotesType::Closed, None, None).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 506: `let result = newton_cotes::<f64>(3, NewtonCotesType::Closed, None, None).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 509: `assert_abs_diff_eq!(result.weights[0], 1.0 / 6.0, epsilon = 1e-14);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 510: `assert_abs_diff_eq!(result.weights[1], 4.0 / 6.0, epsilon = 1e-14);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 511: `assert_abs_diff_eq!(result.weights[2], 1.0 / 6.0, epsilon = 1e-14);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 519: `newton_cotes::<f64>(3, NewtonCotesType::Closed, Some(-1.0), Some(1.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 527: `assert_abs_diff_eq!(result.weights[1], 8.0 / 6.0, epsilon = 1e-14);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 528: `assert_abs_diff_eq!(result.weights[2], 2.0 / 6.0, epsilon = 1e-14);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 534: `let result = newton_cotes::<f64>(3, NewtonCotesType::Open, Some(0.0), Some(1.0))...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 545: `newton_cotes_integrate(|x| x * x, 0.0, 1.0, 3, NewtonCotesType::Closed).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 546: `assert_abs_diff_eq!(result, 1.0 / 3.0, epsilon = 1e-14);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 551: `newton_cotes_integrate(|x| x.sin(), 0.0, PI, 3, NewtonCotesType::Closed).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/chemical.rs

21 issues found:

- Line 338: `/ (arrhenius.gas_constant * self.properties.temperature))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 347: `rate *= concentrations[species_idx].powf(stoich);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 357: `rate = rate * substrate_conc / (km + substrate_conc);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 367: `let substrate_n = substrate_conc.powf(coefficient);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 368: `let k_n = k_half.powf(coefficient);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 369: `rate = rate * substrate_n / (k_n + substrate_n);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 386: `/ (km * (1.0 + inhibitor_conc / ki) + substrate_conc);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 403: `/ ((km + substrate_conc) * (1.0 + inhibitor_conc / ki));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 411: `rate *= concentrations[species_idx].powf(stoich);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 417: `rate /= 1.0 + concentrations[product_idx] / ki;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 580: `max_rate / min_rate`
  - **Fix**: Division without zero check - use safe_divide()
- Line 591: `self.reaction_rate_history.last().unwrap().sum() / num_reactions as f64`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 696: `conservation_matrix: Some(Array2::from_shape_vec((1, 2), vec![1.0, 1.0]).unwrap(...`
  - **Fix**: Handle array creation errors properly
- Line 773: `.unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 909: `let result = integrator.step(0.0, &initial_state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 922: `let result = integrator.step(0.0, &initial_state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 935: `let result = integrator.step(0.0, &initial_state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 951: `let result = integrator.step(0.0, &initial_state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 965: `let result = integrator.step(0.0, &initial_state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 986: `let result = integrator.step(0.0, &initial_state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1003: `let result = integrator.step(0.0, &initial_state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/chemical_equilibrium.rs

41 issues found:

- Line 164: `+ (1.0 / 3.0) * self.cp_coeffs[2] * (t * t * t - t_ref * t_ref * t_ref)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 176: `let delta_s = self.cp_coeffs[0] * (t / t_ref).ln()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 176: `let delta_s = self.cp_coeffs[0] * (t / t_ref).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 179: `+ (1.0 / 3.0) * self.cp_coeffs[3] * (t * t * t - t_ref * t_ref * t_ref);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 186: `self.enthalpy(temperature) - temperature * self.entropy(temperature) / 1000.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 313: `(previous_residual_norm - residual_norm) / previous_residual_norm`
  - **Fix**: Division without zero check - use safe_divide()
- Line 371: `let ln_k_ratio = -delta_h / r * (1.0 / self.temperature - 1.0 / t_standard)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 372: `+ delta_s / r * (self.temperature / t_standard).ln();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 372: `+ delta_s / r * (self.temperature / t_standard).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 443: `let sqrt_i = ionic_strength.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 449: `let log_gamma = -a_dh * charge * charge * sqrt_i / (1.0 + sqrt_i);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 450: `*activity_coeff = 10.0_f64.powf(log_gamma);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 477: `let sqrt_i = ionic_strength.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 487: `let log_gamma = -a_dh * charge * charge * sqrt_i / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 488: `*activity_coeff = 10.0_f64.powf(log_gamma);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 518: `reaction_quotient *= activity.powf(stoich);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 552: `(residuals_pert[reaction_idx] - residuals_orig[reaction_idx]) / perturbation;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 574: `let avg_residual = b[0] / num_species as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 616: `let factor = aug_matrix[(k, i)] / aug_matrix[(i, i)];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 657: `let scale_factor = init_elem / current_elements[i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 691: `let extent = delta_c / stoich;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 699: `extent_estimates.iter().sum::<f64>() / extent_estimates.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 726: `reaction_quotient *= activity.powf(stoich);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 732: `-r * self.temperature * k_eq.ln() + r * self.temperature * reaction_quotient.ln(...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 766: `let x = (-b + discriminant.sqrt()) / (2.0 * a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 766: `let x = (-b + discriminant.sqrt()) / (2.0 * a);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 813: `let h_isoelectric = 10.0_f64.powf(-isoelectric_ph);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 820: `let alpha0 = h2 / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 821: `let alpha1 = ka1 * h / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 822: `let alpha2 = ka1 * ka2 / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 895: `let ratio = guess[species_idx] / (-stoich);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 904: `min_ratio * (k / (1.0 + k)).sqrt() // For small K, use equilibrium approximation`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 936: `let ratio = a_initial / ha_initial.max(1e-12);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 937: `let estimated_h = ka / ratio.max(1e-12);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 938: `let estimated_oh = kw / estimated_h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 963: `let estimated_h = 10.0_f64.powf(-isoelectric_ph);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 970: `let alpha0 = h2 / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 971: `let alpha1 = ka1 * h / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 972: `let alpha2 = ka1 * ka2 / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 986: `let ka_ratio = ka1 / ka2.max(1e-15);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1297: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/enzyme_kinetics.rs

36 issues found:

- Line 240: `vmax * s / (km + s)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 268: `ka * kb + kb * a + ka * b + a * b + (kp * a * q) / kq + (kq * b * p) / kp;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 270: `numerator / denominator`
  - **Fix**: Division without zero check - use safe_divide()
- Line 305: `+ (kp * a * q) / (kq * alpha)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 306: `+ (kq * b * p) / (kp * alpha);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 308: `numerator / denominator`
  - **Fix**: Division without zero check - use safe_divide()
- Line 343: `numerator / denominator`
  - **Fix**: Division without zero check - use safe_divide()
- Line 353: `let s_n = s.powf(*n);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 354: `let kd_n = kd.powf(*n);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 355: `vmax * s_n / (kd_n + s_n)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 381: `let base_rate = vmax * s / (km + s);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 385: `(1.0 + (activator / ka_act).powf(*n_act))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 385: `(1.0 + (activator / ka_act).powf(*n_act))`
  - **Fix**: Mathematical operation .powf( without validation
- Line 386: `/ (1.0 + (activator / ka_act).powf(*n_act))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 386: `/ (1.0 + (activator / ka_act).powf(*n_act))`
  - **Fix**: Mathematical operation .powf( without validation
- Line 392: `1.0 / (1.0 + (inhibitor / ka_inh).powf(*n_inh))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 392: `1.0 / (1.0 + (inhibitor / ka_inh).powf(*n_inh))`
  - **Fix**: Mathematical operation .powf( without validation
- Line 417: `let delta_s_corr = temp_params.delta_s + temp_params.delta_cp * (t / t_ref).ln()...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 417: `let delta_s_corr = temp_params.delta_s + temp_params.delta_cp * (t / t_ref).ln()...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 420: `(-delta_g / (r * t)).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 426: `(-ea / r * (1.0 / self.temperature - 1.0 / t_ref)).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 438: `let alpha = 1.0 / (1.0 + 10.0_f64.powf(pka - ph));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 438: `let alpha = 1.0 / (1.0 + 10.0_f64.powf(pka - ph));`
  - **Fix**: Mathematical operation .powf( without validation
- Line 442: `total_activity / ph_params.pka_values.len() as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 447: `let delta_ph = (self.ph - ph_opt) / ph_width;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 535: `1.0 / (1.0 + effector_conc / regulation.strength)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 538: `1.0 / (1.0 + effector_conc / regulation.strength)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 541: `1.0 / (1.0 + effector_conc / regulation.strength)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 544: `1.0 + effector_conc / regulation.strength`
  - **Fix**: Division without zero check - use safe_divide()
- Line 547: `1.0 / (1.0 + (effector_conc / regulation.strength).powf(2.0))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 547: `1.0 / (1.0 + (effector_conc / regulation.strength).powf(2.0))`
  - **Fix**: Mathematical operation .powf( without validation
- Line 550: `1.0 / (1.0 + (effector_conc / regulation.strength).powf(4.0))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 550: `1.0 / (1.0 + (effector_conc / regulation.strength).powf(4.0))`
  - **Fix**: Mathematical operation .powf( without validation
- Line 636: `((perturbed_flux - base_flux) / base_flux) / perturbation;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 664: `/ base_rates[enzyme_idx])`
  - **Fix**: Division without zero check - use safe_divide()
- Line 665: `/ perturbation;`
  - **Fix**: Division without zero check - use safe_divide()

### ode/mechanical.rs

33 issues found:

- Line 151: `let norm = self.orientation.mapv(|q| q * q).sum().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 286: `(current_energy - prev_energy).abs() / prev_energy.max(1e-12)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 379: `(&new_position - &prev_state.position) / (2.0 * dt)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 493: `.assign(&force_slice.mapv(|f| f / mass));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 516: `angular_acceleration[j] = torques[j] / inertia_jj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 537: `angular_acceleration[3 * i + j] = torque[j] / inertia_jj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 556: `let omega_norm = angular_velocity.mapv(|w| w * w).sum().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 566: `let axis = angular_velocity / omega_norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 640: `let violation = constraint_values.mapv(|c| c * c).sum().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 702: `constraint_values.sum() / combined_pos.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 714: `/ constraint_values.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 718: `/ state.position.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 739: `total.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 773: `let acceleration = constraint_forces.mapv(|f| f / mass);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 776: `Ok((constraint_forces, total_violation.sqrt(), 1, true))`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 822: `Ok((Array1::zeros(0), total_violation.sqrt(), 1, true))`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 837: `let det_check = matrix.mapv(|x| x.abs()).sum() / (n * n) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 879: `let factor = aug_matrix[(k, i)] / aug_matrix[(i, i)];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 922: `let r1 = (x1 * x1 + y1 * y1).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 924: `state.position[0] = x1 * l1 / r1;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 925: `state.position[1] = y1 * l1 / r1;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 935: `let r2 = (dx * dx + dy * dy).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 937: `state.position[3] = state.position[0] + dx * l2 / r2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 938: `state.position[4] = state.position[1] + dy * l2 / r2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 954: `let radial_component1 = (vx1 * x1_new + vy1 * y1_new) / (l1 * l1);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 965: `let radial_component2 = (rel_vx * rel_dx + rel_vy * rel_dy) / (l2 * l2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1044: `let current_energy = *self.energy_history.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1045: `let relative_drift = (current_energy - initial_energy).abs() / initial_energy.ma...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1055: `let max_drift = (max_energy - min_energy) / initial_energy.max(1e-12);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1281: `let norm = state.orientation.mapv(|q| q * q).sum().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1335: `let r1 = (x1 * x1 + y1 * y1).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1352: `let result = integrator.step(0.0, &state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1377: `let result = integrator.step(i as f64 * 0.001, &current_state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/methods/adaptive.rs

51 issues found:

- Line 45: `span / F::from_usize(100).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 51: `span * F::from_f64(1e-8).unwrap() // Minimal step size`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 75: `let c2 = F::from_f64(1.0 / 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 76: `let c3 = F::from_f64(3.0 / 10.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 77: `let c4 = F::from_f64(4.0 / 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 78: `let c5 = F::from_f64(8.0 / 9.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `y_stage[i] = y[i] + h * F::from_f64(1.0 / 5.0).unwrap() * k1[i];`
  - **Fix**: Use .get() with proper bounds checking
- Line 104: `+ h * (F::from_f64(3.0 / 40.0).unwrap() * k1[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 105: `+ F::from_f64(9.0 / 40.0).unwrap() * k2[i]);`
  - **Fix**: Use .get() with proper bounds checking
- Line 112: `+ h * (F::from_f64(44.0 / 45.0).unwrap() * k1[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 113: `+ F::from_f64(-56.0 / 15.0).unwrap() * k2[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 114: `+ F::from_f64(32.0 / 9.0).unwrap() * k3[i]);`
  - **Fix**: Use .get() with proper bounds checking
- Line 121: `+ h * (F::from_f64(19372.0 / 6561.0).unwrap() * k1[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 122: `+ F::from_f64(-25360.0 / 2187.0).unwrap() * k2[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 123: `+ F::from_f64(64448.0 / 6561.0).unwrap() * k3[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 124: `+ F::from_f64(-212.0 / 729.0).unwrap() * k4[i]);`
  - **Fix**: Use .get() with proper bounds checking
- Line 131: `+ h * (F::from_f64(9017.0 / 3168.0).unwrap() * k1[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 132: `+ F::from_f64(-355.0 / 33.0).unwrap() * k2[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 133: `+ F::from_f64(46732.0 / 5247.0).unwrap() * k3[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 134: `+ F::from_f64(49.0 / 176.0).unwrap() * k4[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 135: `+ F::from_f64(-5103.0 / 18656.0).unwrap() * k5[i]);`
  - **Fix**: Use .get() with proper bounds checking
- Line 142: `+ h * (F::from_f64(35.0 / 384.0).unwrap() * k1[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 144: `+ F::from_f64(500.0 / 1113.0).unwrap() * k3[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 145: `+ F::from_f64(125.0 / 192.0).unwrap() * k4[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 146: `+ F::from_f64(-2187.0 / 6784.0).unwrap() * k5[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 147: `+ F::from_f64(11.0 / 84.0).unwrap() * k6[i]);`
  - **Fix**: Use .get() with proper bounds checking
- Line 157: `+ h * (F::from_f64(35.0 / 384.0).unwrap() * k1[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 159: `+ F::from_f64(500.0 / 1113.0).unwrap() * k3[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 160: `+ F::from_f64(125.0 / 192.0).unwrap() * k4[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 161: `+ F::from_f64(-2187.0 / 6784.0).unwrap() * k5[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 162: `+ F::from_f64(11.0 / 84.0).unwrap() * k6[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 170: `+ h * (F::from_f64(5179.0 / 57600.0).unwrap() * k1[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 172: `+ F::from_f64(7571.0 / 16695.0).unwrap() * k3[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 173: `+ F::from_f64(393.0 / 640.0).unwrap() * k4[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 174: `+ F::from_f64(-92097.0 / 339200.0).unwrap() * k5[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 175: `+ F::from_f64(187.0 / 2100.0).unwrap() * k6[i]`
  - **Fix**: Use .get() with proper bounds checking
- Line 176: `+ F::from_f64(1.0 / 40.0).unwrap() * k7[i]);`
  - **Fix**: Use .get() with proper bounds checking
- Line 183: `let err = (y5[i] - y4[i]).abs() / sc;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 188: `let order = F::from_f64(5.0).unwrap(); // 5th order method`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 189: `let exponent = F::one() / (order + F::one());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 190: `let safety = F::from_f64(0.9).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 191: `let factor = safety * (F::one() / err_norm).powf(exponent);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 191: `let factor = safety * (F::one() / err_norm).powf(exponent);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 192: `let factor_min = F::from_f64(0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 193: `let factor_max = F::from_f64(5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 206: `if err_norm <= F::from_f64(0.1).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 208: `h *= factor.max(F::from_f64(2.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 289: `span / F::from_usize(100).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 295: `span * F::from_f64(1e-8).unwrap() // Minimal step size`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 406: `span / F::from_usize(100).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 412: `span * F::from_f64(1e-8).unwrap() // Minimal step size`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/methods/enhanced_bdf.rs

38 issues found:

- Line 60: `span / F::from_usize(100).unwrap() * F::from_f64(0.1).unwrap() // 0.1% of interv...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 66: `span * F::from_f64(1e-10).unwrap() // Minimal step size`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 111: `let two = F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `let half_step = h / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 131: `let slope = (k1 + k2.clone() * two + k3.clone() * two + k4) / F::from_f64(6.0).u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 152: `let mut t = *t_values.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 153: `let mut y = y_values.last().unwrap().clone();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 162: `vec![F::one(), F::from_f64(-1.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 165: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 166: `F::from_f64(-2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 167: `F::from_f64(1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 171: `F::from_f64(11.0 / 6.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 172: `F::from_f64(-3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 173: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 174: `F::from_f64(-1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 178: `F::from_f64(25.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 179: `F::from_f64(-4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 180: `F::from_f64(3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 181: `F::from_f64(-4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 182: `F::from_f64(1.0 / 4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 186: `F::from_f64(137.0 / 60.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 187: `F::from_f64(-5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 188: `F::from_f64(5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 189: `F::from_f64(-10.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 190: `F::from_f64(5.0 / 4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 191: `F::from_f64(-1.0 / 5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `abs_tolerance: opts.rtol * F::from_f64(0.1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 273: `min_damping: F::from_f64(0.1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 288: `newton_iters += F::from(result.iterations).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 317: `y_lower[i] = rhs[i] / lower_coeffs[0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 324: `let err = (y_next[i] - y_lower[i]).abs() / tol_scale[i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 335: `let err_order = F::from_usize(current_order + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 337: `F::from_f64(0.9).unwrap() * (F::one() / error).powf(F::one() / err_order)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 339: `F::from_f64(5.0).unwrap() // Maximum increase if error is zero`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 343: `let factor_max = F::from_f64(5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 344: `let factor_min = F::from_f64(0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 374: `&& (error > F::from_f64(0.5).unwrap() || result.iterations > 8)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 396: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/methods/enhanced_lsoda.rs

132 issues found:

- Line 131: `self.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 136: `self.h *= F::from_f64(0.8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `span * F::from_f64(1e-10).unwrap() // Minimal step size`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 274: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 291: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 353: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 354: `F::from_f64(-1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 358: `F::from_f64(23.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 359: `F::from_f64(-16.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 360: `F::from_f64(5.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 364: `F::from_f64(55.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 365: `F::from_f64(-59.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 366: `F::from_f64(37.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 367: `F::from_f64(-9.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 371: `F::from_f64(1901.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 372: `F::from_f64(-2774.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 373: `F::from_f64(2616.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 374: `F::from_f64(-1274.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 375: `F::from_f64(251.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `F::from_f64(4277.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 380: `F::from_f64(-7923.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 381: `F::from_f64(9982.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 382: `F::from_f64(-7298.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 383: `F::from_f64(2877.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 384: `F::from_f64(-475.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 388: `F::from_f64(198721.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 389: `F::from_f64(-447288.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 390: `F::from_f64(705549.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 391: `F::from_f64(-688256.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 392: `F::from_f64(407139.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 393: `F::from_f64(-134472.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 394: `F::from_f64(19087.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 398: `F::from_f64(434241.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 399: `F::from_f64(-1152169.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 400: `F::from_f64(2183877.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 401: `F::from_f64(-2664477.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 402: `F::from_f64(2102243.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 403: `F::from_f64(-1041723.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 404: `F::from_f64(295767.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `F::from_f64(-36799.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `F::from_f64(14097247.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 410: `F::from_f64(-43125206.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 411: `F::from_f64(95476786.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 412: `F::from_f64(-139855262.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 413: `F::from_f64(137968480.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 414: `F::from_f64(-91172642.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 415: `F::from_f64(38833486.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 416: `F::from_f64(-9664106.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 417: `F::from_f64(1070017.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 421: `F::from_f64(30277247.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 422: `F::from_f64(-104995189.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 423: `F::from_f64(265932680.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 424: `F::from_f64(-454661776.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 425: `F::from_f64(538363838.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 426: `F::from_f64(-444772162.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 427: `F::from_f64(252618224.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 428: `F::from_f64(-94307320.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 429: `F::from_f64(20884811.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 430: `F::from_f64(-2082753.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `F::from_f64(35256204767.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 435: `F::from_f64(-134336876800.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 436: `F::from_f64(385146025457.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `F::from_f64(-754734083733.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 438: `F::from_f64(1045594573504.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 439: `F::from_f64(-1029725952608.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 440: `F::from_f64(717313887930.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 441: `F::from_f64(-344156361067.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 442: `F::from_f64(109301088672.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `F::from_f64(-21157613775.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 444: `F::from_f64(1832380165.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 448: `F::from_f64(77737505967.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `F::from_f64(-328202700680.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 450: `F::from_f64(1074851727475.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 451: `F::from_f64(-2459572352768.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 452: `F::from_f64(4013465151807.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 453: `F::from_f64(-4774671405984.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `F::from_f64(4127030565077.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 455: `F::from_f64(-2538584431976.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 456: `F::from_f64(1077984741336.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 457: `F::from_f64(-295501032385.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 458: `F::from_f64(48902348238.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `F::from_f64(-3525779602.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 470: `F::from_f64(1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 471: `F::from_f64(1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 475: `F::from_f64(5.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 476: `F::from_f64(8.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `F::from_f64(-1.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 481: `F::from_f64(9.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 482: `F::from_f64(19.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 483: `F::from_f64(-5.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 484: `F::from_f64(1.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 582: `let err_order = F::from_usize(order + 1).unwrap(); // Error order is one higher ...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `F::from_f64(0.9).unwrap() * (F::one() / error).powf(F::one() / err_order)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 586: `F::from_f64(5.0).unwrap() // Max increase if error is zero`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 590: `let safety = F::from_f64(0.9).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 591: `let factor_max = F::from_f64(5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `let factor_min = F::from_f64(0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 610: `} else if order > 1 && error > F::from_f64(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 628: `if error > F::from_f64(10.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 652: `vec![F::one(), F::from_f64(-1.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 655: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 656: `F::from_f64(-2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 657: `F::from_f64(1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 661: `F::from_f64(11.0 / 6.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 662: `F::from_f64(-3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 663: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 664: `F::from_f64(-1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 668: `F::from_f64(25.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 669: `F::from_f64(-4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 670: `F::from_f64(3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 671: `F::from_f64(-4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 672: `F::from_f64(1.0 / 4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 676: `F::from_f64(137.0 / 60.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 677: `F::from_f64(-5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 678: `F::from_f64(5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 679: `F::from_f64(-10.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 680: `F::from_f64(5.0 / 4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 681: `F::from_f64(-1.0 / 5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 698: `let newton_tol = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 721: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 748: `state.jacobian.clone().unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 759: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 780: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 783: `if state.h < opts.min_step.unwrap_or(F::from_f64(1e-10).unwrap()) {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 828: `let newton_tol = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 864: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 891: `state.jacobian.clone().unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 902: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 923: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 934: `if state.h < opts.min_step.unwrap_or(F::from_f64(1e-10).unwrap()) {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 956: `state.h *= F::from_f64(1.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 964: `state.h *= F::from_f64(0.8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/methods/explicit.rs

4 issues found:

- Line 154: `let two = F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 155: `let six = F::from_f64(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 168: `let half_step = h_actual / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 178: `let slope = (k1 + k2.clone() * two + k3.clone() * two + k4) / six;`
  - **Fix**: Division without zero check - use safe_divide()

### ode/methods/implicit.rs

71 issues found:

- Line 55: `span / F::from_usize(100).unwrap() * F::from_f64(0.1).unwrap() // 0.1% of interv...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 61: `span * F::from_f64(1e-10).unwrap() // Minimal step size`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 86: `let two = F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `let half_step = h / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 106: `let slope = (k1 + k2.clone() * two + k3.clone() * two + k4) / F::from_f64(6.0).u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 127: `let mut t = *t_values.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 128: `let mut y = y_values.last().unwrap().clone();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 137: `vec![F::one(), F::from_f64(-1.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 140: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 141: `F::from_f64(-2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 142: `F::from_f64(1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 146: `F::from_f64(11.0 / 6.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 147: `F::from_f64(-3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 148: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 149: `F::from_f64(-1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 153: `F::from_f64(25.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 154: `F::from_f64(-4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 155: `F::from_f64(3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 156: `F::from_f64(-4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 157: `F::from_f64(1.0 / 4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 161: `F::from_f64(137.0 / 60.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 162: `F::from_f64(-5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 163: `F::from_f64(5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 164: `F::from_f64(-10.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 165: `F::from_f64(5.0 / 4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 166: `F::from_f64(-1.0 / 5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 199: `y_pred = y.clone() * F::from_f64(2.0).unwrap() - y_nm1 * F::one();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 208: `let b = F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 246: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 259: `let df_dy = (f_perturbed[j] - f_eval[j]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 276: `if jacobian[[0, 0]].abs() < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 278: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 290: `let delta_y0 = residual[0] / jacobian[[0, 0]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 320: `if max_val < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 322: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 344: `let factor = aug[[j, i]] / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 358: `delta_y[i] = sum / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 368: `let newton_tol = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 372: `let e: F = residual[i] / sc;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 384: `newton_iters += F::from(iter_count).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 401: `h *= F::from_f64(1.2).unwrap().min(F::from_f64(5.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `h *= F::from_f64(0.8).unwrap().max(F::from_f64(0.2).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 479: `span / F::from_usize(100).unwrap() * F::from_f64(0.1).unwrap() // 0.1% of interv...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 485: `span * F::from_f64(1e-10).unwrap() // Minimal step size`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 501: `let c1 = F::from_f64(0.1550510257).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 502: `let c2 = F::from_f64(0.6449489743).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 507: `let a11 = F::from_f64(0.1968154772).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 508: `let a12 = F::from_f64(-0.0678338608).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 509: `let a13 = F::from_f64(-0.0207959730).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 511: `let a21 = F::from_f64(0.3944243147).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 512: `let a22 = F::from_f64(0.2921005631).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 513: `let a23 = F::from_f64(0.0416635118).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 515: `let a31 = F::from_f64(0.3764030627).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 516: `let a32 = F::from_f64(0.5124858261).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 517: `let a33 = F::from_f64(0.1111111111).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 542: `let newton_tol = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 595: `max_res = max_res.max(r1[i].abs() / sc);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 596: `max_res = max_res.max(r2[i].abs() / sc);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 597: `max_res = max_res.max(r3[i].abs() / sc);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 623: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 669: `jac[[0, j]] = (r1_perturbed[i] - r1[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 670: `jac[[1, j]] = (r2_perturbed[i] - r2[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 671: `jac[[2, j]] = (r3_perturbed[i] - r3[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 700: `if max_val < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 702: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 724: `let factor = aug[[k, j]] / aug[[j, j]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 738: `delta[j] = sum / aug[[j, j]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 774: `h *= F::from_f64(1.2).unwrap().min(F::from_f64(5.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 777: `h *= F::from_f64(0.8).unwrap().max(F::from_f64(0.2).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 781: `h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/methods/local_extrapolation.rs

29 issues found:

- Line 38: `extrapolation_tol: F::from_f64(1e-12).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 39: `safety_factor: F::from_f64(0.9).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 40: `max_increase_factor: F::from_f64(1.5).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 41: `max_decrease_factor: F::from_f64(0.5).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 107: `span / F::from_usize(100).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 112: `span / F::from_usize(1_000_000).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 117: `span / F::from_usize(10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 158: `(tolerance / error_estimate.max(F::from_f64(1e-14).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 159: `.powf(F::one() / F::from_usize(result.final_order + 1).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 167: `(tolerance / error_estimate)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 168: `.powf(F::one() / F::from_usize(result.final_order + 1).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 239: `let h_sub = h / F::from_usize(n_steps).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 255: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 266: `let ratio = F::from_usize(step_sequence[i]).unwrap()`
  - **Fix**: Use .get() with proper bounds checking
- Line 267: `/ F::from_usize(step_sequence[i - 1]).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 268: `let denominator = ratio.powf(F::from_usize(2 * j).unwrap()) - F::one();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 270: `if denominator.abs() > F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 272: `table[[i, j - 1]] + (table[[i, j - 1]] - table[[i - 1, j - 1]]) / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 350: `let y_next = &y_prev + &dy * (F::from_f64(2.0).unwrap() * h_sub);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 359: `y = (&y + &y_prev + &dy * h_sub) * F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 403: `let h_half = h_sub * F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 404: `let h_sixth = h_sub / F::from_f64(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 413: `+ (&k1 + &k2 * F::from_f64(2.0).unwrap() + &k3 * F::from_f64(2.0).unwrap() + &k4...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 441: `let h_half = h * F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 447: `let y_extrapolated = (&y2 * F::from_f64(4.0).unwrap() - &y1) / F::from_f64(3.0)....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `/ F::from_f64(3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 472: `let result = modified_midpoint_sequence(&f, 0.0, &y0, h / n_steps as f64, n_step...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 490: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 493: `let final_value = result.y.last().unwrap()[0];`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/methods/lsoda.rs

215 issues found:

- Line 446: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 447: `F::from_f64(-1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 451: `F::from_f64(23.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 452: `F::from_f64(-16.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 453: `F::from_f64(5.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 457: `F::from_f64(55.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 458: `F::from_f64(-59.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `F::from_f64(37.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 460: `F::from_f64(-9.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 464: `F::from_f64(1901.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 465: `F::from_f64(-2774.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 466: `F::from_f64(2616.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 467: `F::from_f64(-1274.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 468: `F::from_f64(251.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 472: `F::from_f64(4277.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 473: `F::from_f64(-7923.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 474: `F::from_f64(9982.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 475: `F::from_f64(-7298.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 476: `F::from_f64(2877.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `F::from_f64(-475.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 481: `F::from_f64(198721.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 482: `F::from_f64(-447288.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 483: `F::from_f64(705549.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 484: `F::from_f64(-688256.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 485: `F::from_f64(407139.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 486: `F::from_f64(-134472.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 487: `F::from_f64(19087.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 491: `F::from_f64(434241.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 492: `F::from_f64(-1152169.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 493: `F::from_f64(2183877.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 494: `F::from_f64(-2664477.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 495: `F::from_f64(2102243.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 496: `F::from_f64(-1041723.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 497: `F::from_f64(295767.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 498: `F::from_f64(-36799.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 502: `F::from_f64(14097247.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 503: `F::from_f64(-43125206.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 504: `F::from_f64(95476786.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 505: `F::from_f64(-139855262.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 506: `F::from_f64(137968480.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 507: `F::from_f64(-91172642.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 508: `F::from_f64(38833486.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 509: `F::from_f64(-9664106.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 510: `F::from_f64(1070017.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 514: `F::from_f64(30277247.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 515: `F::from_f64(-104995189.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 516: `F::from_f64(265932680.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 517: `F::from_f64(-454661776.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 518: `F::from_f64(538363838.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 519: `F::from_f64(-444772162.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 520: `F::from_f64(252618224.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 521: `F::from_f64(-94307320.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 522: `F::from_f64(20884811.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 523: `F::from_f64(-2082753.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 527: `F::from_f64(35256204767.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 528: `F::from_f64(-134336876800.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 529: `F::from_f64(385146025457.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 530: `F::from_f64(-754734083733.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 531: `F::from_f64(1045594573504.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 532: `F::from_f64(-1029725952608.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 533: `F::from_f64(717313887930.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 534: `F::from_f64(-344156361067.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 535: `F::from_f64(109301088672.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 536: `F::from_f64(-21157613775.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 537: `F::from_f64(1832380165.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 541: `F::from_f64(77737505967.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 542: `F::from_f64(-328202700680.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 543: `F::from_f64(1074851727475.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 544: `F::from_f64(-2459572352768.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 545: `F::from_f64(4013465151807.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 546: `F::from_f64(-4774671405984.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 547: `F::from_f64(4127030565077.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `F::from_f64(-2538584431976.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 549: `F::from_f64(1077984741336.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 550: `F::from_f64(-295501032385.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 551: `F::from_f64(48902348238.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 552: `F::from_f64(-3525779602.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 563: `F::from_f64(1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 564: `F::from_f64(1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 568: `F::from_f64(5.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 569: `F::from_f64(8.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 570: `F::from_f64(-1.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 574: `F::from_f64(9.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 575: `F::from_f64(19.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 576: `F::from_f64(-5.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 577: `F::from_f64(1.0 / 24.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 581: `F::from_f64(251.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 582: `F::from_f64(646.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 583: `F::from_f64(-264.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `F::from_f64(106.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 585: `F::from_f64(-19.0 / 720.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 590: `F::from_f64(475.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 591: `F::from_f64(1427.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `F::from_f64(-798.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 593: `F::from_f64(482.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 594: `F::from_f64(-173.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 595: `F::from_f64(27.0 / 1440.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 599: `F::from_f64(19087.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 600: `F::from_f64(65112.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 601: `F::from_f64(-46461.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 602: `F::from_f64(37504.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 603: `F::from_f64(-20211.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 604: `F::from_f64(6312.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 605: `F::from_f64(-863.0 / 60480.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 609: `F::from_f64(36799.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 610: `F::from_f64(139849.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 611: `F::from_f64(-121797.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 612: `F::from_f64(123133.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 613: `F::from_f64(-88547.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 614: `F::from_f64(41499.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 615: `F::from_f64(-11351.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 616: `F::from_f64(1375.0 / 120960.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 620: `F::from_f64(1070017.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 621: `F::from_f64(4467094.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 622: `F::from_f64(-4604594.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 623: `F::from_f64(5595358.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 624: `F::from_f64(-5033120.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 625: `F::from_f64(3146338.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 626: `F::from_f64(-1291214.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 627: `F::from_f64(312874.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 628: `F::from_f64(-33953.0 / 3628800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 632: `F::from_f64(2082753.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 633: `F::from_f64(9449717.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 634: `F::from_f64(-11271304.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 635: `F::from_f64(16002320.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 636: `F::from_f64(-17283646.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 637: `F::from_f64(13510082.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 638: `F::from_f64(-7394032.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 639: `F::from_f64(2687864.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 640: `F::from_f64(-583435.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 641: `F::from_f64(57281.0 / 7257600.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 645: `F::from_f64(1832380165.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 646: `F::from_f64(8862145928.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 647: `F::from_f64(-11901858253.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 648: `F::from_f64(19151811844.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 649: `F::from_f64(-23709112128.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 650: `F::from_f64(22186204517.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 651: `F::from_f64(-15364126130.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 652: `F::from_f64(7503814963.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 653: `F::from_f64(-2395311906.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 654: `F::from_f64(467772723.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 655: `F::from_f64(-41469557.0 / 7983360000.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 659: `F::from_f64(3525779602.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 660: `F::from_f64(17870808964.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 661: `F::from_f64(-26564533485.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 662: `F::from_f64(47566383032.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 663: `F::from_f64(-66692205045.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 664: `F::from_f64(72077402760.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 665: `F::from_f64(-59658274307.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 666: `F::from_f64(36174330240.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 667: `F::from_f64(-15568150189.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 668: `F::from_f64(4443502217.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 669: `F::from_f64(-772653805.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 670: `F::from_f64(62628216.0 / 16876492800.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 753: `max_err = max_err.max(err / scale);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 759: `F::from_f64(0.9).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 760: `* (F::one() / max_err).powf(F::one() / F::from_usize(err_order).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 762: `F::from_f64(5.0).unwrap() // Max increase if error is zero`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 766: `let safety = F::from_f64(0.9).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 767: `let factor_max = F::from_f64(5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 768: `let factor_min = F::from_f64(0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 786: `} else if order > 1 && max_err > F::from_f64(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 791: `if max_err < opts.rtol * F::from_f64(0.01).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 803: `if max_err > F::from_f64(10.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 832: `vec![F::one(), F::from_f64(-1.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 835: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 836: `F::from_f64(-2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 837: `F::from_f64(1.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 841: `F::from_f64(11.0 / 6.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 842: `F::from_f64(-3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 843: `F::from_f64(3.0 / 2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 844: `F::from_f64(-1.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 848: `F::from_f64(25.0 / 12.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 849: `F::from_f64(-4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 850: `F::from_f64(3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 851: `F::from_f64(-4.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 852: `F::from_f64(1.0 / 4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 856: `F::from_f64(137.0 / 60.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 857: `F::from_f64(-5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 858: `F::from_f64(5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 859: `F::from_f64(-10.0 / 3.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 860: `F::from_f64(5.0 / 4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 861: `F::from_f64(-1.0 / 5.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 878: `let newton_tol = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 896: `max_res = max_res.max(residual[i].abs() / scale);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 905: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 926: `let df_dy = (f_perturbed[j] - f_eval[j]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 942: `jacobian = state.jacobian.clone().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 970: `if max_val < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 972: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 987: `let factor = aug[[j, i]] / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1001: `delta_y[i] = sum / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1014: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1018: `if state.h < opts.min_step.unwrap_or(F::from_f64(1e-10).unwrap()) {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1066: `let dt_ratio = state.h / (state.t - state.t_history[state.t_history.len() - 1]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1072: `let newton_tol = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1103: `max_res = max_res.max(residual[i].abs() / scale);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1112: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1133: `let df_dy = (f_perturbed[j] - f_eval[j]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1149: `jacobian = state.jacobian.clone().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1177: `if max_val < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1179: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1194: `let factor = aug[[j, i]] / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1208: `delta_y[i] = sum / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1221: `state.h *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1229: `if state.h < opts.min_step.unwrap_or(F::from_f64(1e-10).unwrap()) {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1271: `y_lower[i] = rhs[i] / lower_coeffs[0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1279: `max_err = max_err.max(local_err / scale);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1285: `F::from_f64(0.9).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1286: `* (F::one() / max_err).powf(F::one() / F::from_usize(err_order).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1288: `F::from_f64(5.0).unwrap() // Max increase if error is zero`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1292: `let safety = F::from_f64(0.9).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1293: `let factor_max = F::from_f64(5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1294: `let factor_min = F::from_f64(0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1311: `else if order > 1 && (max_err > F::from_f64(0.5).unwrap() || iter_count > 2) {`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/methods/radau_mass.rs

50 issues found:

- Line 58: `span / F::from_usize(100).unwrap() * F::from_f64(0.1).unwrap() // 0.1% of interv...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 64: `span * F::from_f64(1e-10).unwrap() // Minimal step size`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 80: `let c1 = F::from_f64(0.1550510257).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 81: `let c2 = F::from_f64(0.6449489743).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 86: `let a11 = F::from_f64(0.1968154772).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 87: `let a12 = F::from_f64(-0.0678338608).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 88: `let a13 = F::from_f64(-0.0207959730).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 90: `let a21 = F::from_f64(0.3944243147).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 91: `let a22 = F::from_f64(0.2921005631).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 92: `let a23 = F::from_f64(0.0416635118).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 94: `let a31 = F::from_f64(0.3764030627).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 95: `let a32 = F::from_f64(0.5124858261).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 96: `let a33 = F::from_f64(0.1111111111).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `let base_newton_tol = F::from_f64(1e-6).unwrap(); // Base tolerance`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 188: `let mut newton_tol = base_newton_tol * h.max(F::from_f64(1e-3).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 192: `newton_tol *= F::from_f64(1e8).unwrap(); // Much more relaxed`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 221: `let r1 = (k1.clone() - y.clone()) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 223: `let r2 = (k2.clone() - y.clone()) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 225: `let r3 = (k3.clone() - y.clone()) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 232: `.map(|(r, &w)| (*r / w).powi(2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 236: `.map(|(r, &w)| (*r / w).powi(2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 240: `.map(|(r, &w)| (*r / w).powi(2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 242: `.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 243: `/ F::from_f64(3.0).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 257: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 265: `let jac = jac_option.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 276: `j1[[i, j]] = if i == j { F::one() / h } else { F::zero() };`
  - **Fix**: Division without zero check - use safe_divide()
- Line 279: `j2[[i, j]] = if i == j { F::one() / h } else { F::zero() };`
  - **Fix**: Division without zero check - use safe_divide()
- Line 282: `j3[[i, j]] = if i == j { F::one() / h } else { F::zero() };`
  - **Fix**: Division without zero check - use safe_divide()
- Line 347: `.map(|(r, &w)| (*r / w).powi(2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 351: `.map(|(r, &w)| (*r / w).powi(2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 355: `.map(|(r, &w)| (*r / w).powi(2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 357: `.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 358: `/ F::from_f64(3.0).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 375: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 383: `let jac = jac_option.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 418: `k1 -= &(dk1 * F::from_f64(0.5).unwrap()); // Damped correction`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 431: `k2 -= &(dk2 * F::from_f64(0.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 444: `k3 -= &(dk3 * F::from_f64(0.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 452: `let damp = F::from_f64(0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 463: `h *= F::from_f64(0.8).unwrap(); // Even less aggressive step reduction`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 471: `min_step * F::from_f64(0.1).unwrap() // Allow smaller steps for mass matrix prob...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 505: `.map(|(e, &w)| (*e / w).powi(2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 507: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 530: `if error_norm < F::from_f64(0.1).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 531: `h *= F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 535: `let factor = F::from_f64(0.9).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 536: `* (F::one() / error_norm).powf(F::from_f64(1.0 / 5.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 538: `.max(F::from_f64(0.1).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 539: `.min(F::from_f64(0.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/methods/simd_explicit.rs

49 issues found:

- Line 48: `estimate_initial_step(&f, t_start, &y0.view(), F::from_f64(1e-3).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 127: `estimate_initial_step(&f, t_start, &y0.view(), F::from_f64(1e-3).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 130: `let min_step = opts.min_step.unwrap_or(F::from_f64(1e-12).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `.unwrap_or((t_end - t_start) / F::from_f64(10.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `let abs_tol = opts.abs_tol.unwrap_or(F::from_f64(1e-6).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 135: `let rel_tol = opts.rel_tol.unwrap_or(F::from_f64(1e-6).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 172: `let safety_factor = F::from_f64(0.9).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 174: `safety_factor * (error_tolerance / error_est).powf(F::from_f64(0.2).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 175: `h = h * growth_factor.min(F::from_f64(2.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 177: `h = h * F::from_f64(1.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 182: `let safety_factor = F::from_f64(0.9).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 184: `safety_factor * (error_tolerance / error_est).powf(F::from_f64(0.25).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 185: `h = h * shrink_factor.max(F::from_f64(0.2).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 230: `let h_half = h * F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 248: `let c1 = F::one() / F::from_f64(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 249: `let c2 = F::from_f64(2.0).unwrap() / F::from_f64(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 282: `let a21 = F::from_f64(1.0 / 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 283: `let a31 = F::from_f64(3.0 / 40.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 284: `let a32 = F::from_f64(9.0 / 40.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 285: `let a41 = F::from_f64(44.0 / 45.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 286: `let a42 = F::from_f64(-56.0 / 15.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 287: `let a43 = F::from_f64(32.0 / 9.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 288: `let a51 = F::from_f64(19372.0 / 6561.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 289: `let a52 = F::from_f64(-25360.0 / 2187.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 290: `let a53 = F::from_f64(64448.0 / 6561.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 291: `let a54 = F::from_f64(-212.0 / 729.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 292: `let a61 = F::from_f64(9017.0 / 3168.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 293: `let a62 = F::from_f64(-355.0 / 33.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 294: `let a63 = F::from_f64(46732.0 / 5247.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 295: `let a64 = F::from_f64(49.0 / 176.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 296: `let a65 = F::from_f64(-5103.0 / 18656.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 309: `t + h * F::from_f64(3.0 / 10.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 316: `let k4 = simd_ode_function_eval(f, t + h * F::from_f64(4.0 / 5.0).unwrap(), &y4....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 320: `let k5 = simd_ode_function_eval(f, t + h * F::from_f64(8.0 / 9.0).unwrap(), &y5....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 327: `let b1 = F::from_f64(35.0 / 384.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 328: `let b3 = F::from_f64(500.0 / 1113.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 329: `let b4 = F::from_f64(125.0 / 192.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 330: `let b5 = F::from_f64(-2187.0 / 6784.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 331: `let b6 = F::from_f64(11.0 / 84.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 336: `let b1_star = F::from_f64(5179.0 / 57600.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 337: `let b3_star = F::from_f64(7571.0 / 16695.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 338: `let b4_star = F::from_f64(393.0 / 640.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 339: `let b5_star = F::from_f64(-92097.0 / 339200.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 340: `let b6_star = F::from_f64(187.0 / 2100.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 341: `let b7_star = F::from_f64(1.0 / 40.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `let result = simd_rk4_method(f, t_span, y0, opts).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 446: `let final_value = result.y.last().unwrap()[0];`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 470: `let result = simd_rk45_method(f, t_span, y0, opts).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 473: `let final_y = result.y.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/multirate.rs

26 issues found:

- Line 78: `macro_step: F::from(0.01).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 79: `rtol: F::from(1e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 80: `atol: F::from(1e-9).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `current_macro_step / F::from(*micro_steps).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 108: `current_macro_step / F::from(*micro_steps).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 110: `_ => current_macro_step / F::from(10).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 257: `let dt_micro = dt / F::from(micro_steps).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 270: `t_micro + dt_micro / F::from(2).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 272: `(y_fast_current.clone() + k1_fast.clone() * dt_micro / F::from(2).unwrap()).view...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 275: `t_micro + dt_micro / F::from(2).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 277: `(y_fast_current.clone() + k2_fast.clone() * dt_micro / F::from(2).unwrap()).view...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 285: `let two = F::from(2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 286: `let six = F::from(6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 288: `y_fast_current = y_fast_current + &rk_sum * (dt_micro / six);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 293: `let k2_slow = system.slow_rhs(t + dt / F::from(2).unwrap(), y_slow, y_fast_curre...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 295: `t + dt / F::from(2).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 296: `(y_slow.to_owned() + k1_slow.clone() * dt / F::from(2).unwrap()).view(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 305: `let two = F::from(2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 306: `let six = F::from(6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 308: `let new_y_slow = y_slow.to_owned() + &rk_sum_slow * (dt / six);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 346: `let dt_fast = dt / F::from(100).unwrap(); // Very small steps for fast system`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 401: `Ok(solutions.into_iter().next().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 511: `let result = solver.solve(system, [0.0, 1.0], y0.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 519: `let final_state = result.y.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 553: `let result = solver.solve(system, [0.0, 0.5], y0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 582: `let result = solver.solve(system, [0.0, 0.2], y0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/solver.rs

10 issues found:

- Line 116: `span * F::from_f64(0.01).unwrap() // 1% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 135: `Some(span * F::from_f64(0.05).unwrap()) // 5% of interval instead of default 1%`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 141: `Some(span * F::from_f64(0.0001).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 156: `Some(span * F::from_f64(0.05).unwrap()) // 5% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 161: `Some(span * F::from_f64(0.0001).unwrap()) // 0.01% of span`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 182: `Some(span * F::from_f64(0.01).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 271: `span * F::from_f64(0.01).unwrap() // 1% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 335: `span * F::from_f64(0.01).unwrap() // 1% of interval`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 508: `if (t - last_event.time).abs() < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 526: `if (last_t - last_event.time).abs() > F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/types.rs

2 issues found:

- Line 235: `rtol: F::from_f64(1e-3).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 236: `atol: F::from_f64(1e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/common.rs

18 issues found:

- Line 66: `d0 = d0.max(dy[i].abs() / sc);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 75: `let dt = (F::from_f64(0.01).unwrap() / d0).min(F::from_f64(0.1).unwrap() * (tend...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 78: `let t_new = t + dt * F::from_f64(0.001).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 86: `d1 = d1.max((dy_new[i] - dy[i]).abs() / (sc * (t_new - t)));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 95: `let h1 = (F::from_f64(0.01).unwrap() / d1).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 98: `let mut h = h1.min(dt * F::from_f64(100.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 101: `h = h.min((tend - t).abs() * F::from_f64(0.1).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 127: `let eps_base = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 142: `jacobian[[j, i]] = (f_perturbed[j] - f_eval[j]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 153: `let err = v[i].abs() / scale[i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 203: `if max_val < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 220: `let factor = aug[[j, i]] / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 239: `x[i] = sum / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 260: `if dt.abs() < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 264: `let t_ratio = (t_target - times[1]) / dt;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 286: `let c0 = dt1 * dt2 / (dt01 * dt02);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 287: `let c1 = dt0 * dt2 / (-dt01 * dt12);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 288: `let c2 = dt0 * dt1 / (dt02 * dt12);`
  - **Fix**: Division without zero check - use safe_divide()

### ode/utils/dense_output.rs

17 issues found:

- Line 99: `if (t - ti).abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 154: `let t_min = *self.t.first().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 155: `let t_max = *self.t.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 156: `let dt = (t_max - t_min) / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 162: `let t = t_min + dt * F::from_usize(i).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 224: `let theta = (t - self.t0) / self.h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 236: `let b2 = theta * theta / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 237: `let b3 = theta * theta * theta / F::from_f64(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 238: `let b4 = theta * theta * theta * theta / F::from_f64(24.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 239: `let b5 = theta * theta * theta * theta * theta / F::from_f64(120.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 240: `let b6 = theta * theta * theta * theta * theta * theta / F::from_f64(720.0).unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 242: `theta * theta * theta * theta * theta * theta * theta / F::from_f64(5040.0).unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 286: `let theta = (t - self.t0) / self.h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 298: `let h00 = F::from_f64(2.0).unwrap() * theta.powi(3)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 299: `- F::from_f64(3.0).unwrap() * theta.powi(2)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 301: `let h10 = theta.powi(3) - F::from_f64(2.0).unwrap() * theta.powi(2) + theta;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 303: `F::from_f64(-2.0).unwrap() * theta.powi(3) + F::from_f64(3.0).unwrap() * theta.p...`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/diagnostics.rs

2 issues found:

- Line 42: `let growth = dy / dt;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 88: `let ratio = h2 / h1;`
  - **Fix**: Division without zero check - use safe_divide()

### ode/utils/events.rs

8 issues found:

- Line 70: `threshold: F::from_f64(1e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 217: `let (t_prev, y_prev) = self.last_state.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 255: `dense_output.unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 316: `let tol = F::from_f64(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 341: `t_mid = (t_left + t_right) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 375: `let spec = self.specs.iter().find(|s| s.id == e.id).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 387: `threshold: F::from_f64(1e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 451: `if (ti - t).abs() < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/interpolation.rs

6 issues found:

- Line 40: `let mid = (left + right) / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 79: `let t = (x_new - x0) / (x1 - x0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 126: `let t = (x_new - x0) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 130: `F::from_f64(2.0).unwrap() * t.powi(3) - F::from_f64(3.0).unwrap() * t.powi(2) + ...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 131: `let h10 = t.powi(3) - F::from_f64(2.0).unwrap() * t.powi(2) + t;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 132: `let h01 = F::from_f64(-2.0).unwrap() * t.powi(3) + F::from_f64(3.0).unwrap() * t...`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/jacobian/autodiff.rs

2 issues found:

- Line 72: `let eps = F::from(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 78: `jacobian[[i, j]] = (f_pert[i] - f_vals[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()

### ode/utils/jacobian/mod.rs

33 issues found:

- Line 64: `F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 170: `lower: n_dim / 10,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 171: `upper: n_dim / 10,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 224: `let rel_diff = if old_y[i].abs() > F::from_f64(1e-10).unwrap() {`
  - **Fix**: Use .get() with proper bounds checking
- Line 225: `(y[i] - old_y[i]).abs() / old_y[i].abs()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 235: `F::from_f64(0.3).unwrap(), // 30% change in time`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 236: `F::from_f64(0.3).unwrap(), // 30% change in y`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 239: `F::from_f64(0.1).unwrap(), // 10% change in time`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 240: `F::from_f64(0.1).unwrap(), // 10% change in y`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 243: `F::from_f64(0.01).unwrap(), // 1% change in time`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 244: `F::from_f64(0.01).unwrap(), // 1% change in y`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `let scale_val = scale.unwrap_or_else(|| F::from_f64(1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 293: `let base_eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 326: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 341: `let jac = finite_difference_jacobian(&f, t, y, &f_current, F::from_f64(1e-8).unw...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 368: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 385: `let (_old_t, old_y) = self.state_point.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 386: `let old_f = self.f_eval.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 396: `let mut jac = self.jacobian.as_ref().unwrap().clone();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 407: `if dy_norm_squared > F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 410: `jac[[i, j]] += (delta_f[i] - jac_dy[i]) * delta_y[j] / dy_norm_squared;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 435: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 457: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 506: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 531: `F::from(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 538: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 559: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 589: `jac[[i, j]] = (f_perturbed[i] - f_current[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 632: `let scale_val = scale.unwrap_or_else(|| F::from_f64(1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 644: `let jac = parallel_finite_difference_jacobian(&f, t, y, &f_current, F::from_f64(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 669: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 678: `let jac = parallel_sparse_jacobian(&f, t, y, &f_current, None, F::from_f64(1e-8)...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 703: `Ok(self.jacobian.as_ref().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/jacobian/newton.rs

6 issues found:

- Line 38: `abs_tolerance: F::from_f64(1e-10).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 39: `rel_tolerance: F::from_f64(1e-8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 42: `min_damping: F::from_f64(0.1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 130: `let jacobian = jac_manager.jacobian().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `let neg_residual = residual.clone() * F::from_f64(-1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 158: `damping *= F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/jacobian/parallel.rs

8 issues found:

- Line 60: `let eps_base = F::from_f64(1e-8).unwrap() * perturbation_scale;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 81: `column[i] = (f_perturbed[i] - f_current[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 112: `jacobian[[i, j]] = (f_perturbed[i] - f_current[i]) / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 174: `let eps_base = F::from_f64(1e-8).unwrap() * perturbation_scale;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 224: `column_values.push((i, j, df / eps));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 279: `jacobian[[i, j]] = df / eps;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 533: `parallel_finite_difference_jacobian(&test_func, t, &y, &f_current, 1.0).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 558: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/jacobian/specialized.rs

11 issues found:

- Line 25: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 45: `jac[[i, j]] = (f_perturbed[i] - f_current[i]) / perturbation;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 67: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 72: `let block_idx = j / block_size;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 86: `jac[[i, j]] = (f_perturbed[i] - f_current[i]) / perturbation;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 107: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `jac[[i, j]] = (f_perturbed[i] - f_current[i]) / perturbations[j];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 180: `if dy_norm_squared > F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `jac[[i, j]] += correction[i] * delta_y[j] / dy_norm_squared;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 227: `if dy_norm_squared > F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 230: `jac[[i + start, j + start]] += correction[i] * block_dy[j] / dy_norm_squared;`
  - **Fix**: Division without zero check - use safe_divide()

### ode/utils/linear_solvers/mod.rs

5 issues found:

- Line 77: `if max_val < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 100: `let factor = a_copy[[i, k]] / a_copy[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 124: `x[i] = sum / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 145: `sum.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 163: `sum.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation

### ode/utils/mass_matrix.rs

2 issues found:

- Line 234: `let _thresh = threshold.unwrap_or_else(|| F::from_f64(1e14).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 243: `if matrix[[i, i]].abs() < F::from_f64(1e-14).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/simd_ops.rs

1 issues found:

- Line 128: `sum.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation

### ode/utils/step_control.rs

16 issues found:

- Line 32: `sum_sq += (*e / *s).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 35: `let n = F::from_usize(error.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 36: `(sum_sq / n).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 36: `(sum_sq / n).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 59: `return h_current * F::from_f64(10.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 63: `let order = F::from_usize(error_order).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 64: `let error_ratio = F::one() / error_norm;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 67: `let factor = safety * error_ratio.powf(F::one() / order);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 67: `let factor = safety * error_ratio.powf(F::one() / order);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 70: `let factor_max = F::from_f64(10.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 71: `let factor_min = F::from_f64(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 124: `.map(|(f, s)| *f / *s)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 127: `let d0 = d0.sqrt() / F::from_f64(y.len() as f64).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 129: `let step_size = if d0 < F::from_f64(1.0e-5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 131: `F::from_f64(1.0e-6).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `F::from_f64(0.01).unwrap() / d0`
  - **Fix**: Replace with ? operator or .ok_or()

### ode/utils/stiffness/mod.rs

18 issues found:

- Line 64: `step_size_ratio_threshold: F::from_f64(0.1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 65: `error_ratio_threshold: F::from_f64(10.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 90: `error_pattern_weight: F::from_f64(1.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 91: `step_pattern_weight: F::from_f64(1.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 92: `newton_convergence_weight: F::from_f64(1.5).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 93: `eigenvalue_weight: F::from_f64(2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 215: `if self.error_history[last_idx] < F::from_f64(0.01).unwrap() {`
  - **Fix**: Use .get() with proper bounds checking
- Line 292: `let decrease_ratio = F::from_usize(decreases).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 293: `/ F::from_usize(self.step_size_history.len() - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 295: `if decrease_ratio > F::from_f64(0.7).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 318: `let stiff_score = F::from_usize(self.stiffness_indicators).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 323: `let non_stiff_score = F::from_usize(self.non_stiffness_indicators).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 331: `(stiff_score - non_stiff_score) / (stiff_score + non_stiff_score).max(F::one());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 349: `return self.stiffness_score > F::from_f64(-0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 353: `return self.stiffness_score > F::from_f64(0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 392: `let stiffness_ratio = F::from_f64(10.0).unwrap(); // placeholder`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 395: `if stiffness_ratio > F::from_f64(100.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 397: `} else if stiffness_ratio < F::from_f64(10.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/amr.rs

22 issues found:

- Line 133: `coarsen_threshold: threshold / F::from(4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 141: `coarsen_threshold: threshold / F::from(4.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 149: `coarsen_threshold: threshold / F::from(16.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 194: `(solution[[i + 1, j]] - solution[[i - 1, j]]) / F::from(2.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 202: `(solution[[i, j + 1]] - solution[[i, j - 1]]) / F::from(2.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 205: `(grad_x * grad_x + grad_y * grad_y).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 218: `solution[[i + 1, j]] - F::from(2.0).unwrap() * solution[[i, j]] + solution[[i - ...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 220: `solution[[i, j + 1]] - F::from(2.0).unwrap() * solution[[i, j]] + solution[[i, j...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 224: `/ F::from(4.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 227: `(d2_dx2 * d2_dx2 + d2_dy2 * d2_dy2 + F::from(2.0).unwrap() * d2_dxdy * d2_dxdy)....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 234: `self.compute_curvature(solution, i, j) / F::from(12.0).unwrap() // h error esti...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 241: `let dx = (domain_x[1] - domain_x[0]) / F::from(nx).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 242: `let dy = (domain_y[1] - domain_y[0]) / F::from(ny).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 345: `let child_dx = parent_level.dx / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 346: `let child_dy = parent_level.dy / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 400: `let parent_i = i / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 401: `let parent_j = j / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 433: `averaged_value /= F::from(valid_children).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 549: `total_refined as f64 / total_possible as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 670: `assert_abs_diff_eq!(grid.levels[0].dx, 1.0 / 32.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 671: `assert_abs_diff_eq!(grid.levels[0].dy, 1.0 / 32.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 757: `let coarsened = grid.coarsen_cells(1, cells_to_coarsen).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/elliptic/mod.rs

30 issues found:

- Line 185: `let u_new = ((u[[j, i + 1]] + u[[j, i - 1]]) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 186: `+ (u[[j + 1, i]] + u[[j - 1, i]]) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 188: `/ (2.0 / (dx * dx) + 2.0 / (dy * dy));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 206: `residual_norm = residual_sum.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 272: `a[[index, index]] = -2.0 / (dx * dx) - 2.0 / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 307: `let laplacian = (u[[j, i + 1]] - 2.0 * u[[j, i]] + u[[j, i - 1]]) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 308: `+ (u[[j + 1, i]] - 2.0 * u[[j, i]] + u[[j - 1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 314: `residual_norm = residual_norm.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 374: `let factor = a_copy[[k, i]] / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 392: `x[i] = (b_copy[i] - sum) / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 463: `u[[j, 0]] = (b * u[[j, 1]] / dx + c) / (a + b / dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 471: `u[[j, nx - 1]] = (b * u[[j, nx - 2]] / dx + c) / (a - b / dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 479: `u[[0, i]] = (b * u[[1, i]] / dy + c) / (a + b / dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 487: `u[[ny - 1, i]] = (b * u[[ny - 2, i]] / dy + c) / (a - b / dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 663: `a[[index, index]] = -1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 664: `a[[index, index + 1]] = 1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 680: `a[[index, index - 1]] = -1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 681: `a[[index, index]] = 1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 697: `a[[index, index]] = -1.0 / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 698: `a[[index, index + nx]] = 1.0 / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 714: `a[[index, index - nx]] = -1.0 / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 715: `a[[index, index]] = 1.0 / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 740: `a[[index, index]] = a_coef - b_coef / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 741: `a[[index, index + 1]] = b_coef / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 757: `a[[index, index - 1]] = -b_coef / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 758: `a[[index, index]] = a_coef + b_coef / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 774: `a[[index, index]] = a_coef - b_coef / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 775: `a[[index, index + nx]] = b_coef / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 791: `a[[index, index - nx]] = -b_coef / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 792: `a[[index, index]] = a_coef + b_coef / dy;`
  - **Fix**: Division without zero check - use safe_divide()

### pde/finite_difference/irregular_domains.rs

8 issues found:

- Line 115: `let dx = (x_range.1 - x_range.0) / (nx - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 116: `let dy = (y_range.1 - y_range.0) / (ny - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 289: `let u_ghost = (value - alpha * boundary_value) * 2.0 * h / beta + boundary_value...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 458: `let grid = IrregularGrid::new((-1.5, 1.5), (-1.5, 1.5), 21, 21, domain_func).unw...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 475: `let mut grid = IrregularGrid::new((-0.1, 1.1), (-0.1, 1.1), 13, 13, domain_func)...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 484: `grid.set_boundary_condition(i, j, bc.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 499: `let grid = IrregularGrid::new((0.0, 1.0), (0.0, 1.0), 5, 5, domain_func).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 501: `let laplacian = grid.create_laplacian_matrix().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/finite_difference/mod.rs

90 issues found:

- Line 65: `Ok((u[i + 1] - u[i]) / dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 73: `Ok((u[i] - u[i - 1]) / dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 81: `Ok((u[i + 1] - u[i - 1]) / (2.0 * dx))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 90: `Ok((-u[i + 2] + 8.0 * u[i + 1] - 8.0 * u[i - 1] + u[i - 2]) / (12.0 * dx))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 99: `Ok((u[i + 1] - u[i - 1]) / (2.0 * dx))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 127: `Ok((u[i] - u[i - 1]) / dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 135: `Ok((u[i + 1] - u[i]) / dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 166: `Ok((u[i + 1] - 2.0 * u[i] + u[i - 1]) / (dx * dx))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 178: `/ (12.0 * dx * dx),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 188: `Ok((u[i + 1] - 2.0 * u[i] + u[i - 1]) / (dx * dx))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 210: `matrix[[i, i]] = -1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 211: `matrix[[i, i + 1]] = 1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 214: `matrix[[n - 1, n - 2]] = -1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 215: `matrix[[n - 1, n - 1]] = 1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 219: `matrix[[0, 0]] = -1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 220: `matrix[[0, 1]] = 1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 223: `matrix[[i, i - 1]] = -1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 224: `matrix[[i, i]] = 1.0 / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 229: `matrix[[0, 0]] = -3.0 / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 230: `matrix[[0, 1]] = 4.0 / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 231: `matrix[[0, 2]] = -1.0 / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 234: `matrix[[i, i - 1]] = -1.0 / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 235: `matrix[[i, i + 1]] = 1.0 / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 238: `matrix[[n - 1, n - 3]] = 1.0 / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 239: `matrix[[n - 1, n - 2]] = -4.0 / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 240: `matrix[[n - 1, n - 1]] = 3.0 / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 247: `matrix[[0, 0]] = -25.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 248: `matrix[[0, 1]] = 48.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 249: `matrix[[0, 2]] = -36.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 250: `matrix[[0, 3]] = 16.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 251: `matrix[[0, 4]] = -3.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 254: `matrix[[1, 0]] = -3.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 255: `matrix[[1, 1]] = -10.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 256: `matrix[[1, 2]] = 18.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 257: `matrix[[1, 3]] = -6.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 258: `matrix[[1, 4]] = 1.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 262: `matrix[[i, i - 2]] = 1.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 263: `matrix[[i, i - 1]] = -8.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 264: `matrix[[i, i + 1]] = 8.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 265: `matrix[[i, i + 2]] = -1.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 269: `matrix[[n - 2, n - 5]] = -1.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 270: `matrix[[n - 2, n - 4]] = 6.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 271: `matrix[[n - 2, n - 3]] = -18.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 272: `matrix[[n - 2, n - 2]] = 10.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 273: `matrix[[n - 2, n - 1]] = 3.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 276: `matrix[[n - 1, n - 5]] = 3.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 277: `matrix[[n - 1, n - 4]] = -16.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 278: `matrix[[n - 1, n - 3]] = 36.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 279: `matrix[[n - 1, n - 2]] = -48.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 280: `matrix[[n - 1, n - 1]] = 25.0 / (12.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 311: `matrix[[i, i - 1]] = 1.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 312: `matrix[[i, i]] = -2.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 313: `matrix[[i, i + 1]] = 1.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 318: `matrix[[0, 0]] = 2.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 319: `matrix[[0, 1]] = -5.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 320: `matrix[[0, 2]] = 4.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 321: `matrix[[0, 3]] = -1.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 324: `matrix[[n - 1, n - 4]] = -1.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 325: `matrix[[n - 1, n - 3]] = 4.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 326: `matrix[[n - 1, n - 2]] = -5.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 327: `matrix[[n - 1, n - 1]] = 2.0 / dx2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 333: `matrix[[i, i - 2]] = -1.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 334: `matrix[[i, i - 1]] = 16.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 335: `matrix[[i, i]] = -30.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 336: `matrix[[i, i + 1]] = 16.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 337: `matrix[[i, i + 2]] = -1.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 341: `matrix[[0, 0]] = 45.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 342: `matrix[[0, 1]] = -154.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 343: `matrix[[0, 2]] = 214.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 344: `matrix[[0, 3]] = -156.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 345: `matrix[[0, 4]] = 61.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 346: `matrix[[0, 5]] = -10.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 348: `matrix[[1, 0]] = 10.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 349: `matrix[[1, 1]] = -15.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 350: `matrix[[1, 2]] = -4.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 351: `matrix[[1, 3]] = 14.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 352: `matrix[[1, 4]] = -6.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 353: `matrix[[1, 5]] = 1.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 356: `matrix[[n - 2, n - 6]] = 1.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 357: `matrix[[n - 2, n - 5]] = -6.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 358: `matrix[[n - 2, n - 4]] = 14.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 359: `matrix[[n - 2, n - 3]] = -4.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 360: `matrix[[n - 2, n - 2]] = -15.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 361: `matrix[[n - 2, n - 1]] = 10.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 363: `matrix[[n - 1, n - 6]] = -10.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 364: `matrix[[n - 1, n - 5]] = 61.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 365: `matrix[[n - 1, n - 4]] = -156.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 366: `matrix[[n - 1, n - 3]] = 214.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 367: `matrix[[n - 1, n - 2]] = -154.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 368: `matrix[[n - 1, n - 1]] = 45.0 / (12.0 * dx2);`
  - **Fix**: Division without zero check - use safe_divide()

### pde/finite_element/higher_order.rs

46 issues found:

- Line 181: `-(3.0 * zeta - 1.0) * (3.0 * zeta - 2.0) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 182: `- zeta * 3.0 * (3.0 * zeta - 2.0) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 183: `- zeta * (3.0 * zeta - 1.0) * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 184: `(3.0 * xi - 1.0) * (3.0 * xi - 2.0) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 185: `+ xi * 3.0 * (3.0 * xi - 2.0) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 186: `+ xi * (3.0 * xi - 1.0) * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 189: `9.0 * zeta * (3.0 * zeta - 1.0) / 2.0 - 9.0 * xi * zeta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 190: `9.0 * zeta * (3.0 * xi - 1.0) / 2.0 + 9.0 * xi * zeta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 191: `9.0 * eta * (3.0 * xi - 1.0) / 2.0 + 9.0 * xi * eta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 192: `9.0 * eta * (3.0 * eta - 1.0) / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 193: `-9.0 * eta * zeta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 194: `-9.0 * eta * zeta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 201: `-(3.0 * zeta - 1.0) * (3.0 * zeta - 2.0) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 202: `- zeta * 3.0 * (3.0 * zeta - 2.0) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 203: `- zeta * (3.0 * zeta - 1.0) * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 205: `(3.0 * eta - 1.0) * (3.0 * eta - 2.0) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 206: `+ eta * 3.0 * (3.0 * eta - 2.0) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 207: `+ eta * (3.0 * eta - 1.0) * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 209: `-9.0 * xi * zeta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 210: `-9.0 * xi * zeta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 211: `9.0 * xi * (3.0 * xi - 1.0) / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 212: `9.0 * xi * (3.0 * eta - 1.0) / 2.0 + 9.0 * xi * eta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 213: `9.0 * zeta * (3.0 * eta - 1.0) / 2.0 + 9.0 * eta * zeta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 214: `9.0 * zeta * (3.0 * zeta - 1.0) / 2.0 - 9.0 * eta * zeta * 3.0 / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 244: `let xi = Array1::from_vec(vec![1.0 / 3.0]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 245: `let eta = Array1::from_vec(vec![1.0 / 3.0]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 254: `let weights = Array1::from_vec(vec![1.0 / 6.0, 1.0 / 6.0, 1.0 / 6.0]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 370: `let centroid = Point::new((p1.x + p2.x + p3.x) / 3.0, (p1.y + p2.y + p3.y) / 3.0...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 410: `let midpoint = Point::new((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 439: `let node1_pos = Point::new(p1.x + (p2.x - p1.x) / 3.0, p1.y + (p2.y - p1.y) / 3....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 441: `p1.x + 2.0 * (p2.x - p1.x) / 3.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 442: `p1.y + 2.0 * (p2.y - p1.y) / 3.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 469: `let n = ShapeFunctions::evaluate(ElementType::Linear, 0.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 474: `let n = ShapeFunctions::evaluate(ElementType::Linear, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 479: `let n = ShapeFunctions::evaluate(ElementType::Linear, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 485: `let n = ShapeFunctions::evaluate(ElementType::Linear, 1.0 / 3.0, 1.0 / 3.0).unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 493: `let n = ShapeFunctions::evaluate(ElementType::Quadratic, 1.0 / 3.0, 1.0 / 3.0).u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 498: `let n = ShapeFunctions::evaluate(ElementType::Quadratic, 0.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 508: `let n = ShapeFunctions::evaluate(ElementType::Cubic, 1.0 / 3.0, 1.0 / 3.0).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 513: `let n = ShapeFunctions::evaluate(ElementType::Cubic, 0.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 523: `let (_, _, weights) = TriangularQuadrature::get_rule(1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 527: `let (_, _, weights) = TriangularQuadrature::get_rule(3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 531: `let (_, _, weights) = TriangularQuadrature::get_rule(6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 539: `let linear = HigherOrderTriangle::new(vec![0, 1, 2], ElementType::Linear, None)....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 544: `HigherOrderTriangle::new(vec![0, 1, 2, 3, 4, 5], ElementType::Quadratic, None).u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 550: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/finite_element/higher_order_tests.rs

13 issues found:

- Line 22: `HigherOrderMeshGenerator::linear_to_quadratic(&linear_mesh).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 36: `HigherOrderMeshGenerator::linear_to_cubic(&linear_mesh).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 54: `let (xi, _eta, w) = TriangularQuadrature::get_rule(1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 62: `let (xi, eta, w) = TriangularQuadrature::get_rule(3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 95: `let n_linear = ShapeFunctions::evaluate(ElementType::Linear, xi, eta).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 100: `let n_quad = ShapeFunctions::evaluate(ElementType::Quadratic, xi, eta).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `let n_cubic = ShapeFunctions::evaluate(ElementType::Cubic, xi, eta).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 168: `let xi_ref = [0.0, 1.0, 0.0, 1.0 / 3.0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 169: `let eta_ref = [0.0, 0.0, 1.0, 1.0 / 3.0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 170: `let expected_x = [0.0, 1.0, 0.0, 1.0 / 3.0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 171: `let expected_y = [0.0, 0.0, 1.0, 1.0 / 3.0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 209: `FEMPoissonSolver::new(mesh, source_term, boundary_conditions, Some(options)).unw...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 216: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/finite_element/mod.rs

22 issues found:

- Line 50: `((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 130: `let dx = (x_range.1 - x_range.0) / (nx as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 131: `let dy = (y_range.1 - y_range.0) / (ny as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 261: `Point::new((pj.y - pk.y) / (2.0 * area), (pk.x - pj.x) / (2.0 * area)),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 262: `Point::new((pk.y - pi.y) / (2.0 * area), (pi.x - pk.x) / (2.0 * area)),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 263: `Point::new((pi.y - pj.y) / (2.0 * area), (pj.x - pi.x) / (2.0 * area)),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 530: `let centroid_x = (pi.x + pj.x + pk.x) / 3.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 531: `let centroid_y = (pi.y + pj.y + pk.y) / 3.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 536: `*value = f_centroid * (area / 3.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 571: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `jacobian[[1, 1]] / det_j,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 585: `-jacobian[[0, 1]] / det_j,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 586: `-jacobian[[1, 0]] / det_j,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 587: `jacobian[[0, 0]] / det_j,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 590: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 688: `b[node_idx] += bc_info.value * (edge_length / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 714: `a[[node_idx, node_idx]] += a_coef * edge_length / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 717: `b[node_idx] += c_coef * edge_length / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 772: `let factor = a_copy[[k, i]] / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 790: `x[i] = (b_copy[i] - sum) / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 811: `residual.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 835: `let u_reshaped = result.u.into_shape_with_order((n, 1)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/finite_element/petrov_galerkin.rs

33 issues found:

- Line 148: `x_coords[i] = self.nodes[[i, 0]].to_f64().unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 149: `y_coords[i] = self.nodes[[i, 1]].to_f64().unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 154: `unique_x.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 158: `unique_y.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 195: `let area = det_j.abs() / F::from(2.0).unwrap(); // For triangular elements`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 261: `let b_magnitude = (convection.0 * convection.0 + convection.1 * convection.1).sq...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 265: `let pe = b_magnitude * h / (F::from(2.0).unwrap() * diffusion);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 268: `if pe > F::from(1.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `h / (F::from(2.0).unwrap() * b_magnitude)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 271: `h * h / (F::from(12.0).unwrap() * diffusion)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 372: `if det_j.abs() < F::from(1e-12).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `j22 / det_j, -j12 / det_j,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 380: `-j21 / det_j, j11 / det_j,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 395: `let dist = (dx * dx + dy * dy).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 425: `[F::from(1.0/6.0).unwrap(), F::from(1.0/6.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 426: `[F::from(2.0/3.0).unwrap(), F::from(1.0/6.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 427: `[F::from(1.0/6.0).unwrap(), F::from(2.0/3.0).unwrap()],`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `F::from(1.0/6.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 435: `F::from(1.0/6.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 436: `F::from(1.0/6.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 502: `for i in 0..(bc.nodes.len() / 2) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 504: `let node2 = bc.nodes[bc.nodes.len() / 2 + i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 509: `let penalty = F::from(1e6).unwrap(); // Large penalty parameter`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 529: `F::from(0.1).unwrap() // Default boundary segment length`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 566: `if aug[[k, k]].abs() < F::from(1e-12).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 574: `let factor = aug[[i, k]] / aug[[k, k]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 588: `x[i] = sum / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 649: `]).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 651: `let elements = Array2::from_shape_vec((1, 3), vec![0, 1, 2]).unwrap();`
  - **Fix**: Handle array creation errors properly
- Line 675: `]).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 677: `let elements = Array2::from_shape_vec((1, 3), vec![0, 1, 2]).unwrap();`
  - **Fix**: Handle array creation errors properly
- Line 681: `let element_coords = solver.get_element_coordinates(elements.row(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 682: `let (det_j, _inv_j) = solver.compute_jacobian(&element_coords).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/implicit/adi.rs

25 issues found:

- Line 198: `let num_steps = ((t_end - t_start) / dt).ceil() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 219: `let mut solutions = Vec::with_capacity((num_steps + 1) / save_every + 1);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 395: `let r = 0.5 * d * half_dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 412: `let c = 0.25 * vx * half_dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 474: `a_matrix[[0, 0]] = a_val - 3.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 475: `a_matrix[[0, 1]] = 4.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 476: `a_matrix[[0, 2]] = -b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 518: `a_matrix[[i, i]] = a_val + 3.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 519: `a_matrix[[i, i - 1]] = -4.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 520: `a_matrix[[i, i - 2]] = b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 544: `let r_lower = 0.5 * d_lower * half_dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 545: `let r_upper = 0.5 * d_upper * half_dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 600: `let r = 0.5 * d * half_dt / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 617: `let c = 0.25 * vy * half_dt / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 679: `a_matrix[[0, 0]] = a_val - 3.0 * b_val / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 680: `a_matrix[[0, 1]] = 4.0 * b_val / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 681: `a_matrix[[0, 2]] = -b_val / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 723: `a_matrix[[j, j]] = a_val + 3.0 * b_val / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 724: `a_matrix[[j, j - 1]] = -4.0 * b_val / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 725: `a_matrix[[j, j - 2]] = b_val / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 749: `let r_lower = 0.5 * d_lower * half_dt / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 750: `let r_upper = 0.5 * d_upper * half_dt / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 846: `let w = lower[i - 1] / temp_diag[i - 1];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 852: `solution[n - 1] = temp_rhs[n - 1] / temp_diag[n - 1];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 854: `solution[i] = (temp_rhs[i] - upper[i] * solution[i + 1]) / temp_diag[i];`
  - **Fix**: Division without zero check - use safe_divide()

### pde/implicit/mod.rs

45 issues found:

- Line 247: `let num_steps = ((t_end - t_start) / dt).ceil() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 266: `let mut solutions = Vec::with_capacity((num_steps + 1) / save_every + 1);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 267: `solutions.push(u_current.clone().into_shape_with_order((nx, 1)).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 304: `solutions.push(u_current.clone().into_shape_with_order((nx, 1)).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 365: `let r = 0.5 * d * dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 382: `let c = 0.25 * v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 459: `a_matrix[[0, 0]] = a_val - 3.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 460: `a_matrix[[0, 1]] = 4.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 461: `a_matrix[[0, 2]] = -b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 521: `a_matrix[[i, i]] = a_val + 3.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 522: `a_matrix[[i, i - 1]] = -4.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 523: `a_matrix[[i, i - 2]] = b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 546: `let r = 0.5 * d * dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 559: `let r = 0.5 * d * dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 573: `let c = 0.25 * v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 583: `let c = 0.25 * v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 650: `let w = lower[i - 1] / temp_diag[i - 1];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 656: `solution[n - 1] = temp_rhs[n - 1] / temp_diag[n - 1];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 658: `solution[i] = (temp_rhs[i] - upper[i] * solution[i + 1]) / temp_diag[i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 705: `let factor = a_copy[[k, i]] / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 723: `x[i] = (b_copy[i] - sum) / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 864: `let num_steps = ((t_end - t_start) / dt).ceil() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 883: `let mut solutions = Vec::with_capacity((num_steps + 1) / save_every + 1);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 884: `solutions.push(u_current.clone().into_shape_with_order((nx, 1)).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 919: `solutions.push(u_current.clone().into_shape_with_order((nx, 1)).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 978: `let r = d * dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 992: `let c = v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 997: `let c = -v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1059: `a_matrix[[0, 0]] = a_val - 3.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1060: `a_matrix[[0, 1]] = 4.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1061: `a_matrix[[0, 2]] = -b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1115: `a_matrix[[i, i]] = a_val + 3.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1116: `a_matrix[[i, i - 1]] = -4.0 * b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1117: `a_matrix[[i, i - 2]] = b_val / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1138: `let r = d * dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1147: `let r = d * dt / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1160: `let c = v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1165: `let c = -v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1175: `let c = v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1180: `let c = -v * dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1233: `let w = lower[i - 1] / temp_diag[i - 1];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1239: `solution[n - 1] = temp_rhs[n - 1] / temp_diag[n - 1];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1241: `solution[i] = (temp_rhs[i] - upper[i] * solution[i + 1]) / temp_diag[i];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1298: `let factor = a_copy[[k, i]] / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1316: `x[i] = (b_copy[i] - sum) / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()

### pde/mesh_generation.rs

41 issues found:

- Line 198: `let nx = ((width / self.params.element_size).ceil() as usize).max(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 199: `let ny = ((height / self.params.element_size).ceil() as usize).max(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 201: `let dx = width / (nx - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 202: `let dy = height / (ny - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 260: `let n_theta = ((circumference / self.params.element_size).ceil() as usize).max(8...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 261: `let n_r = ((radius / self.params.element_size).ceil() as usize).max(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 271: `let r = radius * i as f64 / n_r as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 273: `let theta = 2.0 * PI * j as f64 / n_theta as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 342: `point.x *= a / max_radius;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 343: `point.y *= b / max_radius;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 446: `let nx = ((max_x - min_x) / self.params.element_size) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 447: `let ny = ((max_y - min_y) / self.params.element_size) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 451: `let x = min_x + (max_x - min_x) * i as f64 / nx as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 452: `let y = min_y + (max_y - min_y) * j as f64 / ny as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 497: `let n_theta = ((2.0 * PI * outer_radius / self.params.element_size).ceil() as us...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 499: `(((outer_radius - inner_radius) / self.params.element_size).ceil() as usize).max...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 506: `let r = inner_radius + (outer_radius - inner_radius) * i as f64 / n_r as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 508: `let theta = 2.0 * PI * j as f64 / n_theta as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 643: `mesh.points[i].x = new_positions[i].x / neighbor_counts[i] as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 644: `mesh.points[i].y = new_positions[i].y / neighbor_counts[i] as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 679: `let ab = ((b.x - a.x).powi(2) + (b.y - a.y).powi(2)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 680: `let bc = ((c.x - b.x).powi(2) + (c.y - b.y).powi(2)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 681: `let ca = ((a.x - c.x).powi(2) + (a.y - c.y).powi(2)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 685: `((bc.powi(2) + ca.powi(2) - ab.powi(2)) / (2.0 * bc * ca)).acos() * 180.0 / PI;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 687: `((ca.powi(2) + ab.powi(2) - bc.powi(2)) / (2.0 * ca * ab)).acos() * 180.0 / PI;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 697: `let s = (ab + bc + ca) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 698: `let inradius = area / s;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 699: `let circumradius = (ab * bc * ca) / (4.0 * area);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 700: `let aspect_ratio = circumradius / inradius;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 719: `/ (polygon[j].y - polygon[i].y)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 787: `let avg_element_size = (total_area / mesh.elements.len() as f64).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 787: `let avg_element_size = (total_area / mesh.elements.len() as f64).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 788: `let quality_score = 1.0 - (poor_quality_count as f64 / mesh.elements.len() as f6...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 825: `let mesh = generator.generate_mesh(&domain, &boundary_spec).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 852: `let mesh = generator.generate_mesh(&domain, &boundary_spec).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 859: `let distance = (point.x.powi(2) + point.y.powi(2)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 875: `let mesh = generator.generate_mesh(&domain, &boundary_spec).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 912: `let mesh = generator.generate_mesh(&domain, &boundary_spec).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 919: `let distance = (point.x.powi(2) + point.y.powi(2)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 935: `let mesh = generator.generate_mesh(&domain, &boundary_spec).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 961: `let mesh = generator.generate_mesh(&domain, &boundary_spec).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/method_of_lines/hyperbolic.rs

9 issues found:

- Line 207: `let d2u_dx2 = (u[i + 1] - 2.0 * u[i] + u[i - 1]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 242: `let d2u_dx2 = (u[1] - 2.0 * u[0] + u_ghost) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 260: `let du_dx = (c - a * u[0]) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 264: `let d2u_dx2 = (u[1] - 2.0 * u[0] + u_ghost) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 283: `let d2u_dx2 = (u[1] - 2.0 * u[0] + u[nx - 1]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 315: `let d2u_dx2 = (u_ghost - 2.0 * u[nx - 1] + u[nx - 2]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 334: `let du_dx = (c - a * u[nx - 1]) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 339: `(u_ghost - 2.0 * u[nx - 1] + u[nx - 2]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 360: `let d2u_dx2 = (u[0] - 2.0 * u[nx - 1] + u[nx - 2]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()

### pde/method_of_lines/mod.rs

16 issues found:

- Line 251: `let d2u_dx2 = (u[i + 1] - 2.0 * u[i] + u[i - 1]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 256: `let du_dx = (u[i + 1] - u[i - 1]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 290: `let d2u_dx2 = (u[1] - 2.0 * u[0] + u_ghost) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 297: `let du_dx_forward = (u[1] - u[0]) / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 315: `let du_dx = (c - a * u[0]) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 319: `let d2u_dx2 = (u[1] - 2.0 * u[0] + u_ghost) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 326: `let du_dx_forward = (u[1] - u[0]) / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 345: `let d2u_dx2 = (u[1] - 2.0 * u[0] + u[nx - 1]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 352: `let du_dx = (u[1] - u[nx - 1]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 383: `let d2u_dx2 = (u_ghost - 2.0 * u[nx - 1] + u[nx - 2]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 391: `let du_dx_backward = (u[nx - 1] - u[nx - 2]) / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 409: `let du_dx = (c - a * u[nx - 1]) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 414: `(u_ghost - 2.0 * u[nx - 1] + u[nx - 2]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 422: `let du_dx_backward = (u[nx - 1] - u[nx - 2]) / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 441: `let d2u_dx2 = (u[0] - 2.0 * u[nx - 1] + u[nx - 2]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 449: `let du_dx = (u[0] - u[nx - 2]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()

### pde/method_of_lines/mod2d.rs

35 issues found:

- Line 191: `let _u0_flat = u0.clone().into_shape_with_order(nx * ny).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 229: `let u = u_flat.into_shape_with_order((ny, nx)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 240: `let d2u_dx2 = (u[[j, i + 1]] - 2.0 * u[[j, i]] + u[[j, i - 1]]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 241: `let d2u_dy2 = (u[[j + 1, i]] - 2.0 * u[[j, i]] + u[[j - 1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 248: `let du_dx = (u[[j, i + 1]] - u[[j, i - 1]]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 255: `let du_dy = (u[[j + 1, i]] - u[[j - 1, i]]) / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 357: `dudt.into_shape_with_order(nx * ny).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 368: `let u0_flat = u0.clone().into_shape_with_order(nx * ny).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 384: `let u_2d = y_flat.clone().into_shape_with_order((ny, nx)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 465: `(u[[j, i + 1]] - 2.0 * u[[j, i]] + u_ghost) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 467: `(u_ghost - 2.0 * u[[j, i]] + u[[j, i - 1]]) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 471: `let d2u_dy2 = (u[[j + 1, i]] - 2.0 * u[[j, i]] + u[[j - 1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 480: `(u[[j, i + 1]] - u[[j, i]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 482: `(u[[j, i]] - u[[j, i - 1]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 491: `let du_dy = (u[[j + 1, i]] - u[[j - 1, i]]) / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 531: `(u[[j + 1, i]] - 2.0 * u[[j, i]] + u_ghost) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 533: `(u_ghost - 2.0 * u[[j, i]] + u[[j - 1, i]]) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 537: `let d2u_dx2 = (u[[j, i + 1]] - 2.0 * u[[j, i]] + u[[j, i - 1]]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 545: `let du_dx = (u[[j, i + 1]] - u[[j, i - 1]]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 554: `(u[[j + 1, i]] - u[[j, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 556: `(u[[j, i]] - u[[j - 1, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 590: `let du_dn = (c - a * u_val) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 602: `(u[[j, i + 1]] - 2.0 * u[[j, i]] + u_ghost) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 604: `(u_ghost - 2.0 * u[[j, i]] + u[[j, i - 1]]) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 608: `let d2u_dy2 = (u[[j + 1, i]] - 2.0 * u[[j, i]] + u[[j - 1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 617: `(u[[j, i + 1]] - u[[j, i]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 619: `(u[[j, i]] - u[[j, i - 1]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 628: `let du_dy = (u[[j + 1, i]] - u[[j - 1, i]]) / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 656: `let du_dn = (c - a * u_val) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 668: `(u[[j + 1, i]] - 2.0 * u[[j, i]] + u_ghost) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 670: `(u_ghost - 2.0 * u[[j, i]] + u[[j - 1, i]]) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 674: `let d2u_dx2 = (u[[j, i + 1]] - 2.0 * u[[j, i]] + u[[j, i - 1]]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 682: `let du_dx = (u[[j, i + 1]] - u[[j, i - 1]]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 691: `(u[[j + 1, i]] - u[[j, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 693: `(u[[j, i]] - u[[j - 1, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()

### pde/method_of_lines/mod3d.rs

63 issues found:

- Line 222: `let _u0_flat = u0.clone().into_shape_with_order(nx * ny * nz).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 262: `let u = u_flat.into_shape_with_order((nz, ny, nx)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 276: `(u[[k, j, i + 1]] - 2.0 * u[[k, j, i]] + u[[k, j, i - 1]]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 278: `(u[[k, j + 1, i]] - 2.0 * u[[k, j, i]] + u[[k, j - 1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 280: `(u[[k + 1, j, i]] - 2.0 * u[[k, j, i]] + u[[k - 1, j, i]]) / (dz * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 288: `let du_dx = (u[[k, j, i + 1]] - u[[k, j, i - 1]]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 295: `let du_dy = (u[[k, j + 1, i]] - u[[k, j - 1, i]]) / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 302: `let du_dz = (u[[k + 1, j, i]] - u[[k - 1, j, i]]) / (2.0 * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 460: `dudt.into_shape_with_order(nx * ny * nz).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 474: `let u0_flat = u0.into_shape_with_order(nx * ny * nz).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 490: `let u_3d = y_flat.clone().into_shape_with_order((nz, ny, nx)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 594: `(u[[k, j, i + 1]] - 2.0 * u[[k, j, i]] + u_ghost) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 596: `(u_ghost - 2.0 * u[[k, j, i]] + u[[k, j, i - 1]]) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 601: `(u[[k, j + 1, i]] - 2.0 * u[[k, j, i]] + u[[k, j - 1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 603: `(u[[k + 1, j, i]] - 2.0 * u[[k, j, i]] + u[[k - 1, j, i]]) / (dz * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 613: `(u[[k, j, i + 1]] - u[[k, j, i]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 615: `(u[[k, j, i]] - u[[k, j, i - 1]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 624: `let du_dy = (u[[k, j + 1, i]] - u[[k, j - 1, i]]) / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 632: `let du_dz = (u[[k + 1, j, i]] - u[[k - 1, j, i]]) / (2.0 * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 676: `(u[[k, j + 1, i]] - 2.0 * u[[k, j, i]] + u_ghost) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 678: `(u_ghost - 2.0 * u[[k, j, i]] + u[[k, j - 1, i]]) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 683: `(u[[k, j, i + 1]] - 2.0 * u[[k, j, i]] + u[[k, j, i - 1]]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 685: `(u[[k + 1, j, i]] - 2.0 * u[[k, j, i]] + u[[k - 1, j, i]]) / (dz * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 694: `let du_dx = (u[[k, j, i + 1]] - u[[k, j, i - 1]]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 703: `(u[[k, j + 1, i]] - u[[k, j, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 705: `(u[[k, j, i]] - u[[k, j - 1, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 714: `let du_dz = (u[[k + 1, j, i]] - u[[k - 1, j, i]]) / (2.0 * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 758: `(u[[k + 1, j, i]] - 2.0 * u[[k, j, i]] + u_ghost) / (dz * dz)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 760: `(u_ghost - 2.0 * u[[k, j, i]] + u[[k - 1, j, i]]) / (dz * dz)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 765: `(u[[k, j, i + 1]] - 2.0 * u[[k, j, i]] + u[[k, j, i - 1]]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 767: `(u[[k, j + 1, i]] - 2.0 * u[[k, j, i]] + u[[k, j - 1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 776: `let du_dx = (u[[k, j, i + 1]] - u[[k, j, i - 1]]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 784: `let du_dy = (u[[k, j + 1, i]] - u[[k, j - 1, i]]) / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 793: `(u[[k + 1, j, i]] - u[[k, j, i]]) / dz`
  - **Fix**: Division without zero check - use safe_divide()
- Line 795: `(u[[k, j, i]] - u[[k - 1, j, i]]) / dz`
  - **Fix**: Division without zero check - use safe_divide()
- Line 833: `let du_dn = (c - a * u_val) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 845: `(u[[k, j, i + 1]] - 2.0 * u[[k, j, i]] + u_ghost) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 847: `(u_ghost - 2.0 * u[[k, j, i]] + u[[k, j, i - 1]]) / (dx * dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 853: `/ (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 856: `/ (dz * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 869: `(u[[k, j, i + 1]] - u[[k, j, i]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 871: `(u[[k, j, i]] - u[[k, j, i - 1]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 880: `let du_dy = (u[[k, j + 1, i]] - u[[k, j - 1, i]]) / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 888: `let du_dz = (u[[k + 1, j, i]] - u[[k - 1, j, i]]) / (2.0 * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 920: `let du_dn = (c - a * u_val) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 932: `(u[[k, j + 1, i]] - 2.0 * u[[k, j, i]] + u_ghost) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 934: `(u_ghost - 2.0 * u[[k, j, i]] + u[[k, j - 1, i]]) / (dy * dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 940: `/ (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 943: `/ (dz * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 955: `let du_dx = (u[[k, j, i + 1]] - u[[k, j, i - 1]]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 964: `(u[[k, j + 1, i]] - u[[k, j, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 966: `(u[[k, j, i]] - u[[k, j - 1, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 975: `let du_dz = (u[[k + 1, j, i]] - u[[k - 1, j, i]]) / (2.0 * dz);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1007: `let du_dn = (c - a * u_val) / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1019: `(u[[k + 1, j, i]] - 2.0 * u[[k, j, i]] + u_ghost) / (dz * dz)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1021: `(u_ghost - 2.0 * u[[k, j, i]] + u[[k - 1, j, i]]) / (dz * dz)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1027: `/ (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1030: `/ (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1042: `let du_dx = (u[[k, j, i + 1]] - u[[k, j, i - 1]]) / (2.0 * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1050: `let du_dy = (u[[k, j + 1, i]] - u[[k, j - 1, i]]) / (2.0 * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1059: `(u[[k + 1, j, i]] - u[[k, j, i]]) / dz`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1061: `(u[[k, j, i]] - u[[k - 1, j, i]]) / dz`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1198: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### pde/mod.rs

2 issues found:

- Line 140: `Ok((range.end - range.start) / (n_points - 1) as f64)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 154: `let dx = (range.end - range.start) / ((n_points - 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()

### pde/spectral/mod.rs

56 issues found:

- Line 119: `x[j] = (j as f64 * PI / (n - 1) as f64).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 129: `d[[i, j]] = c_i / c_j * (-1.0_f64).powf((i + j) as f64) / (x[i] - x[j]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 129: `d[[i, j]] = c_i / c_j * (-1.0_f64).powf((i + j) as f64) / (x[i] - x[j]);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 158: `x[j] = (j as f64 * PI / (n - 1) as f64).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 172: `let _x_j = (j as f64 * PI / (n - 1) as f64).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 173: `sum += u[j] * (k as f64 * j as f64 * PI / (n - 1) as f64).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 181: `coeffs[k] = 2.0 * sum / norm as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 199: `sum += coeffs[k] * (k as f64 * j as f64 * PI / (n - 1) as f64).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 220: `let quadrature = GaussLegendreQuadrature::<f64>::new(n - 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 237: `let factor = 2.0 / (n as f64 * (n - 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 247: `weights[i] = factor / (p * p);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 259: `points[i] = -(i as f64 * PI / (n - 1) as f64).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 279: `let ddp = (dp_plus - dp_minus) / (2.0 * h);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 287: `delta = f / df;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 300: `let factor = 2.0 / (n as f64 * (n - 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 305: `weights[i] = factor / (p * p);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 327: `let p_next = ((2.0 * k_f64 - 1.0) * x * p - (k_f64 - 1.0) * p_prev) / k_f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 354: `return n as f64 * (n + 1) as f64 / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 357: `return if n % 2 == 0 { -1.0 } else { 1.0 } * n as f64 * (n + 1) as f64 / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 361: `n as f64 * (pn_minus_1 - x * pn) / (1.0 - x * x)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 381: `d[[i, j]] = p_i / (p_j * (x[i] - x[j]));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 453: `let norm = 1.0 / (k as f64 + 0.5);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 533: `grid[i] = range.start + i as f64 * length / n as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 551: `n / 2 + 1`
  - **Fix**: Division without zero check - use safe_divide()
- Line 558: `if i <= n / 2 {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 559: `k[i] = 2.0 * PI * i as f64 / length;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 561: `k[i] = -2.0 * PI * (n - i) as f64 / length;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 576: `u_hat[i] = -f_hat[i] / (k[i] * k[i]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 582: `let cutoff = 2 * n / 3;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 621: `let residual_norm = (residual.mapv(|r| r * r).sum() / n as f64).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 621: `let residual_norm = (residual.mapv(|r| r * r).sum() / n as f64).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 727: `cheb_grid[j] = (j as f64 * PI / (n - 1) as f64).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 733: `grid[j] = a + (b - a) * (cheb_grid[j] + 1.0) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 746: `let scale = 4.0 / ((b - a) * (b - a));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 775: `let deriv_scale = 2.0 / (b - a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 789: `let deriv_scale = 2.0 / (b - a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 824: `let deriv_scale = 2.0 / (b - a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 838: `let deriv_scale = 2.0 / (b - a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 876: `residual_norm = (residual_norm / (n - 2) as f64).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 876: `residual_norm = (residual_norm / (n - 2) as f64).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 937: `let factor = a_copy[[k, i]] / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 955: `x[i] = (b_copy[i] - sum) / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1056: `grid[j] = a + (b - a) * (lgb_grid[j] + 1.0) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1069: `let scale = 4.0 / ((b - a) * (b - a));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1098: `let deriv_scale = 2.0 / (b - a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1112: `let deriv_scale = 2.0 / (b - a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1147: `let deriv_scale = 2.0 / (b - a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1161: `let deriv_scale = 2.0 / (b - a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1199: `residual_norm = (residual_norm / (n - 2) as f64).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1199: `residual_norm = (residual_norm / (n - 2) as f64).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1260: `let factor = a_copy[[k, i]] / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1278: `x[i] = (b_copy[i] - sum) / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1294: `let u_reshaped = u_clone.into_shape_with_order((u_len, 1)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1335: `let angle = -2.0 * PI * (j as f64) * (k as f64) / (n as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1361: `let angle = 2.0 * PI * (j as f64) * (k as f64) / (n as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1365: `result[k] = sum / (n as f64);`
  - **Fix**: Division without zero check - use safe_divide()

### pde/spectral/spectral_element.rs

18 issues found:

- Line 98: `let dx = (x_max - x_min) / nx as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 99: `let dy = (y_max - y_min) / ny as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 540: `let j_det = (dx * dy) / 4.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 543: `let d1_x = d1_ref.mapv(|val| val * 2.0 / dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 544: `let d1_y = d1_ref.mapv(|val| val * 2.0 / dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 568: `dy_tensor[[i, j, idx]] = d1_y[[k, idx / n]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 608: `let i_local = (i % n, i / n);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 609: `let _j_local = (j % n, j / n);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 629: `let x = vertices[0].0 + (xi[ni] + 1.0) * dx / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 630: `let y = vertices[0].1 + (xi[nj] + 1.0) * dy / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 636: `let i_local = (i % n, i / n);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 817: `/ (n_dof - mesh.boundary_nodes.len()) as f64)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 818: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 879: `let factor = a_copy[[k, i]] / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 897: `x[i] = (b_copy[i] - sum) / a_copy[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 916: `x_coords.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 917: `y_coords.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 927: `let u_reshaped = result.u.into_shape_with_order((n_points, 1)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### qmc.rs

34 issues found:

- Line 304: `let sqrt_n = (n as f64).sqrt() as usize;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 327: `result += (transformed_digit % base) as f64 / base_power;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 500: `let delta = volume / (n_points as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 534: `estimates[i] = max_val + sum_exp.ln() + delta.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 562: `max_val + (sum_exp / (n_estimates as f64)).ln()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 562: `max_val + (sum_exp / (n_estimates as f64)).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 564: `estimates.sum() / (n_estimates as f64)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 580: `(variance / (n_estimates as f64)).sqrt().ln()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 580: `(variance / (n_estimates as f64)).sqrt().ln()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 580: `(variance / (n_estimates as f64)).sqrt().ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 590: `(variance / (n_estimates as f64)).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 590: `(variance / (n_estimates as f64)).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 820: `sum += value.exp() / n_points as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 823: `sum += value / n_points as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 828: `sum.ln() + volume.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 876: `sum += value.exp() / n_points as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 879: `sum += value / n_points as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 884: `sum.ln() + volume.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 910: `max_val + (sum_exp / n_estimates as f64).ln()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 910: `max_val + (sum_exp / n_estimates as f64).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 913: `estimates.iter().sum::<f64>() / n_estimates as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 928: `(variance / (n_estimates as f64)).sqrt().ln()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 928: `(variance / (n_estimates as f64)).sqrt().ln()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 928: `(variance / (n_estimates as f64)).sqrt().ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 938: `(variance / (n_estimates as f64)).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 938: `(variance / (n_estimates as f64)).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 974: `let result = qmc_quad(f, &a, &b, Some(8), Some(1000), None, false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 976: `assert_abs_diff_eq!(result.integral, 1.0 / 3.0, epsilon = 0.01);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 986: `let result = qmc_quad(f, &a, &b, Some(8), Some(1000), None, false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 998: `let result = qmc_quad(f, &a, &b, Some(8), Some(1000), None, false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1000: `assert_abs_diff_eq!(result.integral, std::f64::consts::PI.sqrt(), epsilon = 0.05...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1043: `qmc_quad(f, &a, &b, Some(8), Some(1000), Some(Box::new(faure)), false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1060: `qmc_quad_parallel(f, &a, &b, Some(8), Some(1000), None, false, Some(2)).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1063: `assert_abs_diff_eq!(result.integral, 2.0 / 3.0, epsilon = 0.1);`
  - **Fix**: Division without zero check - use safe_divide()

### quad.rs

23 issues found:

- Line 28: `abs_tol: F::from_f64(1.49e-8).unwrap(), // Default from SciPy`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 29: `rel_tol: F::from_f64(1.49e-8).unwrap(), // Default from SciPy`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 81: `let h = (b - a) / F::from_usize(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 82: `let mut sum = F::from_f64(0.5).unwrap() * (f(a) + f(b));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `let x = a + F::from_usize(i).unwrap() * h;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 129: `let h = (b - a) / F::from_usize(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `let x = a + F::from_usize(i).unwrap() * h;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 143: `(f(a) + f(b) + F::from_f64(2.0).unwrap() * sum_even + F::from_f64(4.0).unwrap() ...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 145: `/ F::from_f64(3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 191: `abs_error: F::from_f64(1e-8).unwrap(), // Rough estimate`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 270: `let mid = (a + b) / F::from_f64(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 312: `let h = (b - a) / F::from_usize(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 321: `let x = a + F::from_usize(i).unwrap() * h;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 331: `(fa + fb + F::from_f64(2.0).unwrap() * sum_even + F::from_f64(4.0).unwrap() * su...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 332: `/ F::from_f64(3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 346: `assert_relative_eq!(result, 1.0 / 3.0, epsilon = 1e-4);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 359: `let result = simpson(|x| x * x, 0.0, 1.0, 100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 360: `assert_relative_eq!(result, 1.0 / 3.0, epsilon = 1e-8);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 365: `let result = simpson(|x| x.sin(), 0.0, pi, 100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 378: `let result = quad(|x| x * x, 0.0, 1.0, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `assert_relative_eq!(result.value, 1.0 / 3.0, epsilon = 1e-8);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 393: `std::f64::consts::PI / 2.0,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 396: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### quad_vec.rs

19 issues found:

- Line 158: `sum_squares.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 214: `let fval = f((a + b) / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 238: `|| (point - filtered_points.last().unwrap()).abs() > f64::EPSILON)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 256: `intervals.push((*filtered_points.last().unwrap(), b));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 266: `let fval = f((intervals[0].0 + intervals[0].1) / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 313: `let mid = (interval.a + interval.b) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 532: `let h = (b - a) / (n as f64 - 1.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 583: `let mid = (a + b) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 584: `let half_length = (b - a) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 622: `error[i] = (200.0 * diff).powf(1.5);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 639: `let result = quad_vec(f, 0.0, 1.0, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 642: `assert_abs_diff_eq!(result.integral[1], 1.0 / 3.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 650: `let result = quad_vec(f, 0.0, PI, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 667: `let result = quad_vec(f, 0.0, 2.0, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 670: `assert_abs_diff_eq!(result.integral[1], 8.0 / 3.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 694: `let result_gk15 = quad_vec(f, 0.0, PI, Some(options_gk15)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 695: `let result_gk21 = quad_vec(f, 0.0, PI, Some(options_gk21)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 696: `let result_trapezoid = quad_vec(f, 0.0, PI, Some(options_trapezoid)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 714: `(1.0f64 * 1.0 + 2.0 * 2.0 + 0.5 * 0.5).sqrt(),`
  - **Fix**: Mathematical operation .sqrt() without validation

### romberg.rs

52 issues found:

- Line 34: `abs_tol: F::from_f64(1.0e-10).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 35: `rel_tol: F::from_f64(1.0e-10).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 110: `let coef = F::from_f64(4.0_f64.powi(j as i32) - 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 112: `r_table[[i, j - 1]] + (r_table[[i, j - 1]] - r_table[[i - 1, j - 1]]) / coef;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 139: `F::from_f64(1.0e-3).unwrap() * value.abs()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 295: `let h1 = (b1 - a1) / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 296: `let h2 = (b2 - a2) / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 303: `let x = a1 + F::from_usize(i).unwrap() * h1;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 305: `F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 311: `let y = a2 + F::from_usize(j).unwrap() * h2;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 313: `F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 333: `let refined_n = n_points / 2 + (n_points % 2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 334: `let refined_h1 = (b1 - a1) / F::from_usize(refined_n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 335: `let refined_h2 = (b2 - a2) / F::from_usize(refined_n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 338: `let x = a1 + F::from_usize(i).unwrap() * refined_h1;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 340: `F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 346: `let y = a2 + F::from_usize(j).unwrap() * refined_h2;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 348: `F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 375: `let abs_error = result.abs() * F::from_f64(1e-3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 389: `let n_points = (opts.max_iters / 2 + 1).min(11);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 391: `let h1 = (b1 - a1) / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 392: `let h2 = (b2 - a2) / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 393: `let h3 = (b3 - a3) / F::from_usize(n_points - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 399: `let x = a1 + F::from_usize(i).unwrap() * h1;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 401: `F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 407: `let y = a2 + F::from_usize(j).unwrap() * h2;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 415: `let z = a3 + F::from_usize(k).unwrap() * h3;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 417: `F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `let abs_error = result.abs() * F::from_f64(1e-2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 474: `.map(|&(a, b)| Uniform::new_inclusive(a, b).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 485: `let n_samples_per_strata = n_samples / strata.pow(n_dims as u32).max(1);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 519: `let n_samples_f = F::from_usize(n_actual_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 520: `let mean = sum / n_samples_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 524: `let variance = (sum_squares - sum * sum / n_samples_f) / (n_samples_f - F::one()...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 525: `let std_error = (variance / n_samples_f).sqrt() * volume;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 525: `let std_error = (variance / n_samples_f).sqrt() * volume;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 544: `let result = romberg(|x| x * x, 0.0, 1.0, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 545: `assert_relative_eq!(result.value, 1.0 / 3.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 549: `let result = romberg(|x| x.sin(), 0.0, PI, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 555: `let result = romberg(|x: f64| (-x * x).exp(), -1.0, 1.0, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 556: `let exact = PI.sqrt() * libm::erf(1.0);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 572: `let result = romberg(|x| x * x, 0.0, 1.0, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 573: `assert_relative_eq!(result.value, 1.0 / 3.0, epsilon = 1e-12);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 586: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 589: `assert_relative_eq!(result.value, 2.0 / 3.0, epsilon = 1e-3);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 600: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 602: `assert_relative_eq!(result.value, 1.0 / 27.0, epsilon = 1e-2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 614: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `assert_relative_eq!(result.value, 1.0 / 81.0, epsilon = 1e-1);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 633: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 635: `assert_relative_eq!(result.value, 2.0 / 3.0, epsilon = 5e-2);`
  - **Fix**: Division without zero check - use safe_divide()

### scheduling.rs

25 issues found:

- Line 103: `(self.func.take().unwrap())()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 276: `let mut global_queue = self.global_queue.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 286: `let mut global_queue = self.global_queue.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 301: `let global_empty = self.global_queue.lock().unwrap().is_empty();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 305: `.all(|state| state.local_queue.lock().unwrap().is_empty());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 321: `let mut stats = self.stats.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 333: `.map(|state| *state.computation_time.lock().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 343: `completed as f64 / stats.total_tasks as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 347: `let ideal_load = 1.0 / self.worker_states.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 352: `/ self.worker_states.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 375: `let mut task_opt = my_state.local_queue.lock().unwrap().pop_back();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `task_opt = global_queue.lock().unwrap().pop_back();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 401: `*my_state.computation_time.lock().unwrap() += computation_time;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `.wait_timeout(cv_mutex.lock().unwrap(), Duration::from_millis(10))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 406: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 418: `stats.lock().unwrap().steal_attempts += 1;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 429: `let queue = victim_state.local_queue.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 441: `let mut victim_queue = victim_state.local_queue.lock().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 445: `stats.lock().unwrap().successful_steals += 1;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 502: `h * (fa + fb) / F::from(2.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 508: `let mid = (a + b) / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 558: `let mid = (a + b) / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 563: `tolerance: self.tolerance / F::from(2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 571: `tolerance: self.tolerance / F::from(2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 640: `pool.execute_and_wait().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### specialized/finance.rs

100 issues found:

- Line 394: `let dt = option.maturity / (self.n_time - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 396: `let ds = s_max / (self.n_asset - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 454: `let spot_idx = (option.spot / ds) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 455: `let alpha = option.spot / ds - spot_idx as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 475: `let dt = option.maturity / (self.n_time - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 479: `let ds = s_max / (self.n_asset - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 483: `let dv = v_max / (n_vol - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 515: `let alpha_s = 0.5 * v * s * s / (ds * ds);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 516: `let beta_s = option.risk_free_rate * s / (2.0 * ds);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 523: `let alpha_v = 0.5 * sigma * sigma * v / (dv * dv);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 524: `let beta_v = kappa * (theta - v) / (2.0 * dv);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 551: `let alpha_v = 0.5 * sigma * sigma * v / (dv * dv);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 552: `let beta_v = kappa * (theta - v) / (2.0 * dv);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 573: `let s_idx = (option.spot / ds).min(self.n_asset as f64 - 1.0) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 574: `let v_idx = (v0 / dv).min(n_vol as f64 - 1.0) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 591: `let n_steps = (option.maturity / dt) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 628: `let avg_price = paths.0.iter().sum::<f64>() / paths.0.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 660: `let avg_payoff = payoffs.iter().sum::<f64>() / payoffs.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 680: `let s_new = s_path.last().unwrap() *`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 681: `(drift * dt + sigma * dt.sqrt() * z).exp();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 714: `let original_return = (original_path.0[i + 1] / original_path.0[i]).ln();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 714: `let original_return = (original_path.0[i + 1] / original_path.0[i]).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 715: `let z = -(original_return - drift * dt) / (sigma * dt.sqrt());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 715: `let z = -(original_return - drift * dt) / (sigma * dt.sqrt());`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 717: `let s_new = s_path.last().unwrap() *`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 718: `(drift * dt + sigma * dt.sqrt() * z).exp();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 749: `let w2 = rho * z1 + (1.0 - rho * rho).sqrt() * z2;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 752: `let v_curr = v_path.last().unwrap().max(0.0);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 754: `+ sigma * v_curr.sqrt() * dt.sqrt() * w2;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 758: `let s_curr = s_path.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 760: `let s_new = s_curr * (drift * dt + v_curr.sqrt() * dt.sqrt() * w1).exp();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 794: `let d1 = ((s / k).ln() + (r - q + 0.5 * sigma * sigma) * t) / (sigma * t.sqrt())...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 794: `let d1 = ((s / k).ln() + (r - q + 0.5 * sigma * sigma) * t) / (sigma * t.sqrt())...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 794: `let d1 = ((s / k).ln() + (r - q + 0.5 * sigma * sigma) * t) / (sigma * t.sqrt())...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 795: `let d2 = d1 - sigma * t.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 841: `let integrand = (phi * (-u * (s / k).ln()).exp()).re / (u * u + 0.25);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 841: `let integrand = (phi * (-u * (s / k).ln()).exp()).re / (u * u + 0.25);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 845: `let price = s - k.sqrt() * s.sqrt() * integral / PI;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 845: `let price = s - k.sqrt() * s.sqrt() * integral / PI;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 869: `+ sigma * sigma * (u * i + u * u)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 871: `let g = (kappa - rho * sigma * u * i - d) / (kappa - rho * sigma * u * i + d);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 873: `let c = kappa * theta / (sigma * sigma) * (`
  - **Fix**: Division without zero check - use safe_divide()
- Line 875: `- 2.0 * ((1.0 - g * (-d * t).exp()) / (1.0 - g)).ln()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 875: `- 2.0 * ((1.0 - g * (-d * t).exp()) / (1.0 - g)).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 878: `let d_term = (kappa - rho * sigma * u * i - d) / (sigma * sigma)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 879: `* (1.0 - (-d * t).exp()) / (1.0 - g * (-d * t).exp());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 898: `let dt = option.maturity / n_steps as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 899: `let u = (sigma * dt.sqrt()).exp();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 900: `let d = 1.0 / u;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 901: `let p = ((option.risk_free_rate - option.dividend_yield) * dt - d) / (u - d);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 938: `0.5 * (1.0 + self.erf(x / SQRT_2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 954: `let t = 1.0 / (1.0 + p * x);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 974: `c_star[0] = c[0] / b[0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 975: `d_star[0] = d[0] / b[0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 979: `c_star[i] = c[i] / m;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 980: `d_star[i] = (d[i] - a[i] * d_star[i-1]) / m;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 984: `d_star[n-1] = (d[n-1] - a[n-1] * d_star[n-2]) / m;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1027: `let delta = (price_up - price_down) / (2.0 * h * option.spot);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1030: `let gamma = (price_up - 2.0 * base_price + price_down) / (h * option.spot).powi(...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1036: `let theta = -(base_price - price_later) / (h * option.maturity);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1042: `let rho = (price_high_rate - base_price) / h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1055: `(price_vol_up - base_price) / h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1080: `let jump_size = 1.0 + rng.sample(Normal::new(*mu_jump, *sigma_jump).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1091: `1.0 + rng.sample(rand_distr::Exp::new(*eta_up).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1094: `1.0 - rng.sample(rand_distr::Exp::new(*eta_down).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1103: `let jump_size = 1.0 + rng.sample(Normal::new(*mu, sigma_squared.sqrt()).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1113: `let jump_size = 1.0 + rng.sample(Normal::new(*mu_jump, *sigma_jump).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1137: `let omega = (1.0 / nu) * ((1.0 - theta * nu - 0.5 * sigma * sigma * nu).sqrt() -...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1137: `let omega = (1.0 / nu) * ((1.0 - theta * nu - 0.5 * sigma * sigma * nu).sqrt() -...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1141: `let gamma_shape = dt / nu;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1143: `let time_change = rng.sample(rand_distr::Gamma::new(gamma_shape, gamma_scale).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1147: `let increment = (omega + theta) * time_change + sigma * time_change.sqrt() * z;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1149: `let s_new = s_path.last().unwrap() * increment.exp();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1173: `let gamma = (alpha * alpha - beta * beta).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1177: `let ig_mean = delta / gamma;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1183: `let increment = mu * dt + beta * v + (alpha * alpha - beta * beta).sqrt() * v.sq...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1185: `let s_new = s_path.last().unwrap() * increment.exp();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1199: `let x = mu + (mu * mu * y) / (2.0 * lambda) -`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1200: `(mu / (2.0 * lambda)) * (4.0 * mu * lambda * y + mu * mu * y * y).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1200: `(mu / (2.0 * lambda)) * (4.0 * mu * lambda * y + mu * mu * y * y).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1203: `if test <= mu / (mu + x) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1206: `mu * mu / x`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1234: `let lambda_pos = c * dt * gamma_fn(1.0 - y) / g.powf(1.0 - y);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1234: `let lambda_pos = c * dt * gamma_fn(1.0 - y) / g.powf(1.0 - y);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 1235: `let lambda_neg = c * dt * gamma_fn(1.0 - y) / m.powf(1.0 - y);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1235: `let lambda_neg = c * dt * gamma_fn(1.0 - y) / m.powf(1.0 - y);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 1238: `let n_pos = rng.sample(rand_distr::Poisson::new(lambda_pos).unwrap()) as usize;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1241: `let jump = (u.powf(-1.0 / (1.0 - y)) - 1.0) / g;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1241: `let jump = (u.powf(-1.0 / (1.0 - y)) - 1.0) / g;`
  - **Fix**: Mathematical operation .powf( without validation
- Line 1248: `let n_neg = rng.sample(rand_distr::Poisson::new(lambda_neg).unwrap()) as usize;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1251: `let jump = -((u.powf(-1.0 / (1.0 - y)) - 1.0) / m);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1251: `let jump = -((u.powf(-1.0 / (1.0 - y)) - 1.0) / m);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 1257: `let s_new = s_path.last().unwrap() * jump_sum.exp();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1271: `(2.0 * PI / x).sqrt() * (x / std::f64::consts::E).powf(x)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1271: `(2.0 * PI / x).sqrt() * (x / std::f64::consts::E).powf(x)`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1271: `(2.0 * PI / x).sqrt() * (x / std::f64::consts::E).powf(x)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 1274: `gamma_fn(x + 1.0) / x`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1322: `let call_price = solver.price_option(&call).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1323: `let put_price = solver.price_option(&put).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1351: `let greeks = solver.calculate_greeks(&option).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### specialized/fluid_dynamics.rs

91 issues found:

- Line 116: `let n_steps = (t_final / self.params.dt).ceil() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 186: `let x_back = i as f64 - u[[j, i]] * self.params.dt / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 187: `let y_back = j as f64 - v[[j, i]] * self.params.dt / dy;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 225: `(u[[j, i]] - u[[j, i-1]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 227: `(u[[j, i+1]] - u[[j, i]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 232: `(u[[j, i]] - u[[j-1, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 234: `(u[[j+1, i]] - u[[j, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 251: `(v[[j, i]] - v[[j, i-1]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 253: `(v[[j, i+1]] - v[[j, i]]) / dx`
  - **Fix**: Division without zero check - use safe_divide()
- Line 258: `(v[[j, i]] - v[[j-1, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 260: `(v[[j+1, i]] - v[[j, i]]) / dy`
  - **Fix**: Division without zero check - use safe_divide()
- Line 295: `let d2u_dx2 = (u[[j, i+1]] - 2.0 * u[[j, i]] + u[[j, i-1]]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 296: `let d2u_dy2 = (u[[j+1, i]] - 2.0 * u[[j, i]] + u[[j-1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 300: `let d2v_dx2 = (v[[j, i+1]] - 2.0 * v[[j, i]] + v[[j, i-1]]) / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 301: `let d2v_dy2 = (v[[j+1, i]] - 2.0 * v[[j, i]] + v[[j-1, i]]) / (dy * dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 323: `let div_u = (u_star[[j, i+1]] - u_star[[j, i-1]]) / (2.0 * state.dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 324: `+ (v_star[[j+1, i]] - v_star[[j-1, i]]) / (2.0 * state.dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 325: `rhs[[j, i]] = -self.params.rho * div_u / self.params.dt;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 337: `(pressure[[j, i+1]] + pressure[[j, i-1]]) / (state.dx * state.dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 338: `+ (pressure[[j+1, i]] + pressure[[j-1, i]]) / (state.dy * state.dy)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 340: `) / (2.0 / (state.dx * state.dx) + 2.0 / (state.dy * state.dy));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 372: `let dt_over_rho = self.params.dt / self.params.rho;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 377: `let dp_dx = (pressure[[j, i+1]] - pressure[[j, i-1]]) / (2.0 * u_star.dim().1 as...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 381: `let dp_dy = (pressure[[j+1, i]] - pressure[[j-1, i]]) / (2.0 * u_star.dim().0 as...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 590: `let dx = 1.0 / (nx - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 591: `let dy = 1.0 / (ny - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 605: `let dx = 2.0 * PI / (nx - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 606: `let dy = 2.0 * PI / (ny - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 617: `u[[j, i]] = a * (x / a).cos() * (y / b).sin();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 618: `v[[j, i]] = -b * (x / a).sin() * (y / b).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 619: `pressure[[j, i]] = -0.25 * ((2.0 * x / a).cos() + (2.0 * y / b).cos());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 649: `let states = solver.solve_2d(initial_state, 0.1, 10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 660: `let div = (u[[j, i+1]] - u[[j, i-1]]) / (2.0 * state.dx)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 661: `+ (v[[j+1, i]] - v[[j-1, i]]) / (2.0 * state.dy);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 689: `let states = solver.solve_2d(initial_state, 0.1, 10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 692: `let final_state = states.last().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 762: `let dt = final_time / n_steps as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 810: `let delta = (self.dx * self.dy * self.dz).powf(1.0/3.0); // Filter width`
  - **Fix**: Mathematical operation .powf( without validation
- Line 824: `s_mag = (2.0 * s_mag).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 848: `let delta = (self.dx * self.dy * self.dz).powf(1.0/3.0);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 884: `s_mag = (2.0 * s_mag).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 906: `let delta = (self.dx * self.dy * self.dz).powf(1.0/3.0);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 929: `let trace = (s_d[[0, 0]] + s_d[[1, 1]] + s_d[[2, 2]]) / 3.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 946: `let numerator = s_d_mag_sq.powf(1.5);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 947: `let denominator = (s_d_mag_sq.powf(2.5) + omega_mag_sq.powf(1.25)).max(1e-12);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 948: `let nu_sgs = (cw * delta).powi(2) * numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 967: `let delta = (self.dx * self.dy * self.dz).powf(1.0/3.0);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 999: `(cv as f64).powi(2) * delta.powi(2) * (b_beta / alpha_norm_sq).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 999: `(cv as f64).powi(2) * delta.powi(2) * (b_beta / alpha_norm_sq).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1024: `let dudx = (state.velocity[0][[i + 1, j]] - state.velocity[0][[i - 1, j]]) / (2....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1025: `let dudy = (state.velocity[0][[i, j + 1]] - state.velocity[0][[i, j - 1]]) / (2....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1028: `let dvdx = (state.velocity[1][[i + 1, j]] - state.velocity[1][[i - 1, j]]) / (2....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1029: `let dvdy = (state.velocity[1][[i, j + 1]] - state.velocity[1][[i, j - 1]]) / (2....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1051: `grad_u[[0, 0, i, j]] = (state.velocity[0][[i + 1, j]] - state.velocity[0][[i - 1...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1052: `grad_u[[0, 1, i, j]] = (state.velocity[0][[i, j + 1]] - state.velocity[0][[i, j ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1053: `grad_u[[1, 0, i, j]] = (state.velocity[1][[i + 1, j]] - state.velocity[1][[i - 1...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1054: `grad_u[[1, 1, i, j]] = (state.velocity[1][[i, j + 1]] - state.velocity[1][[i, j ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1066: `let filter_weight = 1.0 / (filter_width * filter_width) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1153: `let dudx = (state.velocity[0][[i + 1, j]] - state.velocity[0][[i - 1, j]]) / (2....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1154: `let dudy = (state.velocity[0][[i, j + 1]] - state.velocity[0][[i, j - 1]]) / (2....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1155: `let dvdx = (state.velocity[1][[i + 1, j]] - state.velocity[1][[i - 1, j]]) / (2....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1156: `let dvdy = (state.velocity[1][[i, j + 1]] - state.velocity[1][[i, j - 1]]) / (2....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1159: `let dpdx = (state.pressure[[i + 1, j]] - state.pressure[[i - 1, j]]) / (2.0 * se...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1160: `let dpdy = (state.pressure[[i, j + 1]] - state.pressure[[i, j - 1]]) / (2.0 * se...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1163: `let dsgs_xx_dx = (sgs_stress[[0, 0, i + 1, j]] - sgs_stress[[0, 0, i - 1, j]]) /...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1164: `let dsgs_xy_dy = (sgs_stress[[0, 1, i, j + 1]] - sgs_stress[[0, 1, i, j - 1]]) /...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1165: `let dsgs_yx_dx = (sgs_stress[[1, 0, i + 1, j]] - sgs_stress[[1, 0, i - 1, j]]) /...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1166: `let dsgs_yy_dy = (sgs_stress[[1, 1, i, j + 1]] - sgs_stress[[1, 1, i, j - 1]]) /...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1316: `let nu_t = c_mu * k * k / epsilon;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1327: `let depsilon_dt = c_1 * epsilon / k * production - c_2 * epsilon * epsilon / k;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1351: `.unwrap_or(state.dissipation_rate[[i, j]] / k)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1355: `let nu_t = k / omega;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1366: `let domega_dt = alpha * omega / k * production - beta * omega * omega;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1421: `let time_scale = k / epsilon;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1438: `let depsilon_dt = c_eps1 * epsilon / k * production - c_eps2 * epsilon * epsilon...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1467: `Ok((state.mean_velocity[0][[i + 1, j]] - state.mean_velocity[0][[i - 1, j]]) / (...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1471: `Ok((state.mean_velocity[1][[i, j + 1]] - state.mean_velocity[1][[i, j - 1]]) / (...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1475: `let dudy = (state.mean_velocity[0][[i, j + 1]] - state.mean_velocity[0][[i, j - ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1476: `let dvdx = (state.mean_velocity[1][[i + 1, j]] - state.mean_velocity[1][[i - 1, ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1491: `f1[[i, j]] = (-(y_plus / 0.09).powi(4)).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1506: `let nu_t = 0.09 * k * k / epsilon.max(1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1513: `let du_dt = -u * (u - state.mean_velocity[0][[i - 1, j]]) / state.dx +`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1514: `nu_t * (state.mean_velocity[0][[i + 1, j]] - 2.0 * u + state.mean_velocity[0][[i...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1516: `let dv_dt = -v * (v - state.mean_velocity[1][[i, j - 1]]) / state.dy +`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1517: `nu_t * (state.mean_velocity[1][[i, j + 1]] - 2.0 * v + state.mean_velocity[1][[i...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1565: `let dudx = (state.mean_velocity[0][[i + 1, j]] - state.mean_velocity[0][[i - 1, ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1566: `let dvdy = (state.mean_velocity[1][[i, j + 1]] - state.mean_velocity[1][[i, j - ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1573: `Ok(residual / count as f64)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1620: `let results = solver.solve_3d(initial_state, 0.1, 5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1647: `let result = solver.solve_rans(initial_state, 10, 1e-6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1676: `let sgs_stress = solver.compute_sgs_stress(&state).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### specialized/quantum.rs

58 issues found:

- Line 44: `let norm = norm_squared.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 46: `self.psi.mapv_inplace(|c| c / norm);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 65: `let dpsi_dx = (self.psi[i+1] - self.psi[i-1]) / (2.0 * self.dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 137: `-self.z * self.e2_4pi_eps0 / r`
  - **Fix**: Division without zero check - use safe_divide()
- Line 193: `let n_steps = (t_final / self.dt).ceil() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 238: `let phase = -v[i] * self.dt / (2.0 * REDUCED_PLANCK);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 250: `let dk = 2.0 * PI / (n as f64 * state.dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 253: `if i <= n / 2 {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 264: `let kinetic_phase = -REDUCED_PLANCK * k * k * self.dt / (2.0 * state.mass);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 279: `let phase = -v[i] * self.dt / (2.0 * REDUCED_PLANCK);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 292: `let alpha = Complex64::new(0.0, REDUCED_PLANCK * self.dt / (4.0 * state.mass * s...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 301: `let v_term = Complex64::new(0.0, -v[i] * self.dt / (2.0 * REDUCED_PLANCK));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 315: `let v_term = Complex64::new(0.0, v[i] * self.dt / (2.0 * REDUCED_PLANCK));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 343: `let prefactor = Complex64::new(0.0, -1.0 / REDUCED_PLANCK);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 353: `} / state.dx.powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 356: `let h_psi = -REDUCED_PLANCK.powi(2) / (2.0 * state.mass) * d2psi_dx2`
  - **Fix**: Division without zero check - use safe_divide()
- Line 379: `let prefactor = Complex64::new(0.0, -1.0 / REDUCED_PLANCK);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 388: `} / state.dx.powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 390: `let h_psi = -REDUCED_PLANCK.powi(2) / (2.0 * state.mass) * d2psi_dx2`
  - **Fix**: Division without zero check - use safe_divide()
- Line 400: `let k2 = compute_derivative(&(&state.psi + &k1 * (self.dt / 2.0)));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 401: `let k3 = compute_derivative(&(&state.psi + &k2 * (self.dt / 2.0)));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 405: `state.psi += &((k1 + k2 * 2.0 + k3 * 2.0 + k4) * (self.dt / 6.0));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 427: `c_star[0] = c[0] / b[0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 428: `d_star[0] = d[0] / b[0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 432: `c_star[i] = c[i] / m;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 433: `d_star[i] = (d[i] - a[i] * d_star[i-1]) / m;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 452: `let dx = (x_max - x_min) / (self.n_points - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 496: `let norm: f64 = psi.iter().map(|&x| x * x * dx).sum::<f64>().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 546: `let norm: f64 = psi.iter().map(|&x| x * x * dx).sum::<f64>().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 558: `indices.sort_by(|&i, &j| energies[i].partial_cmp(&energies[j]).unwrap());`
  - **Fix**: Use .get() with proper bounds checking
- Line 577: `let norm = 1.0 / (2.0 * PI * sigma.powi(2)).powf(0.25);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 577: `let norm = 1.0 / (2.0 * PI * sigma.powi(2)).powf(0.25);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 579: `let gaussian = norm * (-(xi - x0).powi(2) / (4.0 * sigma.powi(2))).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 600: `let (energies, _) = solver.solve_time_independent(-5.0, 5.0, 3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `let states = solver.solve_time_dependent(&initial_state, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 628: `let final_position = states.last().unwrap().expectation_position();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 657: `let t = i as f64 / (n_schedule_points - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 818: `gradients[i] = (energy_plus - energy_minus) / (2.0 * epsilon);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 828: `let gradient_norm = gradients.iter().map(|&g| g * g).sum::<f64>().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 891: `let cos_z = (theta_z / 2.0).cos();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 892: `let sin_z = (theta_z / 2.0).sin();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 975: `let norm = norm_sq.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 976: `orbital.mapv_inplace(|c| c / norm);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1021: `let normalization = ((alpha / pi).sqrt() / (2.0_f64.powi(n as i32) * factorial_n...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1021: `let normalization = ((alpha / pi).sqrt() / (2.0_f64.powi(n as i32) * factorial_n...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1022: `let hermite = self.hermite_polynomial(n, alpha.sqrt() * x);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1023: `let gaussian = (-alpha * x * x / 2.0).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1053: `hamiltonian[[i, i - 1]] = -0.5 / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1056: `hamiltonian[[i, i + 1]] = -0.5 / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1058: `hamiltonian[[i, i]] = 1.0 / (dx * dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1071: `let mut eigenvector = Array1::from_elem(n_grid, Complex64::new(1.0 / (n_grid as ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1071: `let mut eigenvector = Array1::from_elem(n_grid, Complex64::new(1.0 / (n_grid as ...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1084: `let norm = norm_sq.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1085: `new_vec.mapv_inplace(|c| c / norm);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1112: `let laplacian = (orbital[i + 1] - 2.0 * orbital[i] + orbital[i - 1]) / (dx * dx)...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1148: `let (spins, energy) = annealer.solve_ising(&j_matrix, &h_fields).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1163: `let (energy, _params) = vqe.find_ground_state(&hamiltonian).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1178: `let (energy, orbitals) = solver.solve_hartree_fock(&grid).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### symbolic/conservation.rs

30 issues found:

- Line 114: `let half_n = n / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 143: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 146: `Box::new(Constant(F::from(2.0).unwrap())),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 203: `F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 230: `(Var(v), Constant(c)) if v == var => Some(F::one() / *c),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 253: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 255: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 393: `F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 417: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 440: `F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 479: `let scale = (target / current).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 479: `let scale = (target / current).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 528: `Box::new(Constant(F::from(0.5).unwrap())),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 531: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 540: `F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 591: `laws.push(ConservationLaw::new("Linear Momentum X", px, F::from(1e-10).unwrap())...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `laws.push(ConservationLaw::new("Linear Momentum Y", py, F::from(1e-10).unwrap())...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 593: `laws.push(ConservationLaw::new("Linear Momentum Z", pz, F::from(1e-10).unwrap())...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 594: `laws.push(ConservationLaw::new("Angular Momentum X", lx, F::from(1e-10).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 595: `laws.push(ConservationLaw::new("Angular Momentum Y", ly, F::from(1e-10).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 596: `laws.push(ConservationLaw::new("Angular Momentum Z", lz, F::from(1e-10).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 615: `Box::new(Constant(F::from(0.5).unwrap())),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 616: `Box::new(Pow(Box::new(v), Box::new(Constant(F::from(2.0).unwrap()))))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 626: `Box::new(Constant(F::from(0.5).unwrap())),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 627: `Box::new(Pow(Box::new(x.clone()), Box::new(Constant(F::from(2.0).unwrap()))))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 635: `Box::new(Constant(F::from(0.5).unwrap())),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 636: `Box::new(Pow(Box::new(diff), Box::new(Constant(F::from(2.0).unwrap()))))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 641: `laws.push(ConservationLaw::new("Total Energy", energy, F::from(1e-10).unwrap()))...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 649: `laws.push(ConservationLaw::new("Total Momentum", total_momentum, F::from(1e-10)....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 674: `let value = law.evaluate(0.0, state.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### symbolic/conversion.rs

6 issues found:

- Line 215: `Box::new(Constant(F::from(2.0).unwrap())),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 223: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 248: `let g_over_l = SymbolicExpression::constant(g / l);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 274: `let f_over_ei = SymbolicExpression::constant(f / ei);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 341: `let ode = HigherOrderODE::new(2, "x", "t", expr).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 342: `let system = higher_order_to_first_order(&ode).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### symbolic/expression.rs

20 issues found:

- Line 239: `Box::new(Constant(F::from(2.0).unwrap())),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 250: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 262: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 287: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 324: `Ok(a.evaluate(values)? / b_val)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 327: `Pow(a, b) => Ok(a.evaluate(values)?.powf(b.evaluate(values)?)),`
  - **Fix**: Mathematical operation .powf( without validation
- Line 337: `Ok(a_val.ln())`
  - **Fix**: Mathematical operation .ln() without validation
- Line 345: `Ok(a_val.sqrt())`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 412: `if (*n_a - F::from(2.0).unwrap()).abs() < F::epsilon()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 413: `&& (*n_b - F::from(2.0).unwrap()).abs() < F::epsilon() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 424: `&& (*n1 - F::from(2.0).unwrap()).abs() < F::epsilon()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 425: `&& (*n2 - F::from(2.0).unwrap()).abs() < F::epsilon() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 436: `if (*n_a - F::from(2.0).unwrap()).abs() < F::epsilon()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `&& (*n_b - F::from(2.0).unwrap()).abs() < F::epsilon() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `(Constant(x), Constant(y)) if y.abs() > F::epsilon() => Constant(*x / *y),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 566: `(Constant(x), Constant(y)) => Constant(x.powf(*y)),`
  - **Fix**: Mathematical operation .powf( without validation
- Line 585: `Constant(x) if *x > F::zero() => Constant(x.ln()),`
  - **Fix**: Mathematical operation .ln() without validation
- Line 618: `Constant(x) if *x >= F::zero() => Constant(x.sqrt()),`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 622: `Pow(base.clone(), Box::new(Constant(*n / F::from(2.0).unwrap())))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 702: `Div(a, b) => write!(f, "({} / {})", a, b),`
  - **Fix**: Division without zero check - use safe_divide()

### symbolic/jacobian.rs

12 issues found:

- Line 209: `Box::new(Constant(F::from(2.0).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 236: `let k1 = SymbolicExpression::constant(F::from(0.04).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 237: `let k2 = SymbolicExpression::constant(F::from(1e4).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 238: `let k3 = SymbolicExpression::constant(F::from(3e7).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 265: `let a = constant(F::from(1.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 266: `let b = constant(F::from(0.1).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 267: `let c = constant(F::from(0.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 268: `let d = constant(F::from(0.75).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `let e = constant(F::from(0.25).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 270: `let two_pi = constant(F::from(std::f64::consts::TAU).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 326: `).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 332: `let j = jacobian.evaluate(0.0, ArrayView1::from(&[1.0])).unwrap();`
  - **Fix**: Handle array creation errors properly

### symplectic/composition.rs

25 issues found:

- Line 61: `let two_to_third = two.powf(F::from_f64(1.0 / 3.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 62: `let w1 = F::one() / (two - two_to_third);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 63: `let w0 = -two_to_third / (two - two_to_third);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 87: `let w1 = F::from_f64(0.784513610477560).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 88: `let w2 = F::from_f64(0.235573213359357).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 89: `let w3 = F::from_f64(-1.17767998417887).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 90: `let w4 = F::from_f64(1.31518632068391).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 115: `F::from_f64(0.74167036435061).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 116: `F::from_f64(-0.40910082580003).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 117: `F::from_f64(0.19075471029623).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 118: `F::from_f64(-0.57386247111608).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 119: `F::from_f64(0.29906418130365).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 120: `F::from_f64(0.33462491824529).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `F::from_f64(0.31529309239676).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `F::from_f64(-0.79688793935291).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 214: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 221: `((q_base[0] - q_exact[0]).powi(2) + (p_base[0] - p_exact[0]).powi(2)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 227: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 234: `((q_fourth[0] - q_exact[0]).powi(2) + (p_fourth[0] - p_exact[0]).powi(2)).sqrt()...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 242: `let base_ratio = base_errors[i] / base_errors[i + 1];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 243: `let fourth_ratio = fourth_errors[i] / fourth_errors[i + 1];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 274: `let r = (q[0] * q[0] + q[1] * q[1]).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 278: `-1.0 / r`
  - **Fix**: Division without zero check - use safe_divide()
- Line 301: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 304: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### symplectic/euler.rs

3 issues found:

- Line 171: `let (q1_a, p1_a) = symplectic_euler_a(&system, t0, &q0, &p0, dt).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 174: `let (q1_b, p1_b) = symplectic_euler_b(&system, t0, &q0, &p0, dt).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 207: `let result = integrator.integrate(&system, t0, tf, dt, q0, p0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### symplectic/leapfrog.rs

15 issues found:

- Line 57: `let p_half = p + &(&dp1 * (dt / (F::one() + F::one())));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 60: `let t_half = t + dt / (F::one() + F::one());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 67: `let p_new = p_half + &(&dp2 * (dt / (F::one() + F::one())));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 97: `let p_half = p + &(&dp_old * (dt / F::from(2.0).unwrap()));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 100: `let dq = system.dq_dt(t + dt / F::from(2.0).unwrap(), q, &p_half)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `let p_new = &p_half + &(&dp_new * (dt / F::from(2.0).unwrap()));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 156: `let steps = (period / dt).round() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 164: `let (q_new, p_new) = integrator.step(&system, t, &q, &p, dt).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 194: `let steps = (period / dt).round() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 202: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 212: `let (q_new, p_new) = velocity_verlet(&system, t0, &q2, &p2, dt).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 236: `let r = (q[0] * q[0] + q[1] * q[1]).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 240: `-1.0 / r`
  - **Fix**: Division without zero check - use safe_divide()
- Line 258: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 268: `let r = (q[0] * q[0] + q[1] * q[1]).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation

### symplectic/mod.rs

4 issues found:

- Line 154: `let n_steps = (t_span / dt).ceil().to_f64().unwrap() as usize;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 155: `let actual_dt = t_span / F::from_usize(n_steps).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 197: `if initial_energy.abs() > F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 198: `Some((final_energy - initial_energy).abs() / initial_energy.abs())`
  - **Fix**: Division without zero check - use safe_divide()

### symplectic/potential.rs

21 issues found:

- Line 117: `p.iter().map(|&pi| pi * pi).sum::<F>() * F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `q.iter().map(|&qi| qi * qi).sum::<F>() * F::from_f64(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 139: `let kinetic = |_t: F, p: &Array1<F>| -> F { F::from_f64(0.5).unwrap() * p[0] * p...`
  - **Fix**: Handle array creation errors properly
- Line 160: `|_t: F, p: &Array1<F>| -> F { F::from_f64(0.5).unwrap() * (p[0] * p[0] + p[1] * ...`
  - **Fix**: Handle array creation errors properly
- Line 163: `let r = (q[0] * q[0] + q[1] * q[1]).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 164: `if r < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 167: `-F::one() / r`
  - **Fix**: Division without zero check - use safe_divide()
- Line 175: `let r = r2.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 177: `if r < F::from_f64(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 181: `let factor = F::one() / r3;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 197: `let h = F::from_f64(1e-6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 210: `dq[i] = (t_plus - t_minus) / (F::from_f64(2.0).unwrap() * h);`
  - **Fix**: Use .get() with proper bounds checking
- Line 225: `let h = F::from_f64(1e-6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 239: `dp[i] = -(v_plus - v_minus) / (F::from_f64(2.0).unwrap() * h);`
  - **Fix**: Use .get() with proper bounds checking
- Line 357: `let dq = system.dq_dt(t0, &q0, &p0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 358: `let dp = system.dp_dt(t0, &q0, &p0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 369: `let energy = hamiltonian(t0, &q0, &p0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 398: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 446: `let dq = system.dq_dt(t0, &q0, &p0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 447: `let dp = system.dp_dt(t0, &q0, &p0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 455: `let energy = hamiltonian(t0, &q0, &p0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### symplectic/runge_kutta.rs

37 issues found:

- Line 50: `let half = F::one() / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 51: `let quarter = half / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 52: `let sqrt_3 = F::from_f64(3.0_f64.sqrt()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 53: `let sixth = F::one() / (F::from_f64(6.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 115: `if max_err < F::from_f64(1e-12).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 169: `let _half = F::one() / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 174: `let c1 = F::from_f64(0.5 - 0.1 * 15.0_f64.sqrt()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 175: `let c2 = F::from_f64(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 176: `let c3 = F::from_f64(0.5 + 0.1 * 15.0_f64.sqrt()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `F::from_f64(5.0 / 36.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 184: `F::from_f64(2.0 / 9.0 - 1.0 / 15.0 * 15.0_f64.sqrt()).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 185: `F::from_f64(5.0 / 36.0 - 1.0 / 30.0 * 15.0_f64.sqrt()).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 186: `F::from_f64(5.0 / 36.0 + 1.0 / 24.0 * 15.0_f64.sqrt()).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 187: `F::from_f64(2.0 / 9.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 188: `F::from_f64(5.0 / 36.0 - 1.0 / 24.0 * 15.0_f64.sqrt()).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 189: `F::from_f64(5.0 / 36.0 + 1.0 / 30.0 * 15.0_f64.sqrt()).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 190: `F::from_f64(2.0 / 9.0 + 1.0 / 15.0 * 15.0_f64.sqrt()).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 191: `F::from_f64(5.0 / 36.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 194: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 197: `let b1 = F::from_f64(5.0 / 18.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 198: `let b2 = F::from_f64(4.0 / 9.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 199: `let b3 = F::from_f64(5.0 / 18.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 263: `if err_max < F::from_f64(1e-12).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 318: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 321: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 324: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 328: `let verlet_error = ((verlet_result.q.last().unwrap()[0] - 1.0).powi(2)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 329: `+ verlet_result.p.last().unwrap()[0].powi(2))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 330: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 332: `let gl4_error = ((gl4_result.q.last().unwrap()[0] - 1.0).powi(2)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 333: `+ gl4_result.p.last().unwrap()[0].powi(2))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 334: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 336: `let gl6_error = ((gl6_result.q.last().unwrap()[0] - 1.0).powi(2)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 337: `+ gl6_result.p.last().unwrap()[0].powi(2))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 338: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 381: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 384: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### tanhsinh.rs

34 issues found:

- Line 82: `let h = 1.0 / (1 << level) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 86: `let max_j = (max_t / h) as i32;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 112: `let w = h * std::f64::consts::FRAC_PI_2 * cosh_t / (cosh_arg * cosh_arg);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 126: `let mid = (a + b) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 127: `let len = (b - a) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 373: `let jacobian = 1.0 / (1.0 - t).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 376: `points[i] = *a + t / (1.0 - t);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 395: `let jacobian = 1.0 / (1.0 - t).powi(2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 398: `points[i] = *b - t / (1.0 - t);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 420: `let jacobian = (1.0 + t_squared) / (denominator * denominator);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 423: `points[i] = t / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 470: `val += weights[i].ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 487: `state.estimate = max_val + sum.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 563: `integral: std::f64::consts::PI.sqrt(),`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 603: `let transformed_x = t / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 606: `let jacobian = (1.0 + t_squared) / (denominator * denominator);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 724: `if a.is_finite() && b.is_finite() && (b - a) / step <= max_terms as f64 {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 787: `let integrate_start = remainder_start - step / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 788: `let integrate_end = if b.is_finite() { b + step / 2.0 } else { b };`
  - **Fix**: Division without zero check - use safe_divide()
- Line 794: `let total_sum = direct_sum + integral_result.integral / step;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 795: `let total_error = integral_result.error / step;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 815: `let result = tanhsinh(|x| x * x, 0.0, 1.0, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 816: `assert_abs_diff_eq!(result.integral, 1.0 / 3.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 823: `let result = tanhsinh(|x| x.sin(), 0.0, PI, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 836: `let result = tanhsinh(|x| 1.0 / x.sqrt(), 0.0, 1.0, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 844: `let result = tanhsinh(|x| (-x).exp(), 0.0, f64::INFINITY, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 855: `infinite_range_integral(|x| (-x * x).exp(), TanhSinhOptions::default()).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 857: `assert_abs_diff_eq!(result.integral, PI.sqrt(), epsilon = 1e-8);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 869: `let result = tanhsinh(|x| -1000.0 * x * x, -1.0, 1.0, Some(options)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 871: `let expected = (PI / 1000.0).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 871: `let expected = (PI / 1000.0).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 879: `let result = nsum(|n| n, 1.0, 10.0, 1.0, None, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 887: `let result = nsum(|n| 1.0 / (n * n), 1.0, f64::INFINITY, 1.0, None, None).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 889: `let expected = PI * PI / 6.0;`
  - **Fix**: Division without zero check - use safe_divide()

### utils.rs

2 issues found:

- Line 283: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 344: `let eps = F::from_f64(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### verification.rs

15 issues found:

- Line 51: `let h = F::from(1e-8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 61: `(deriv_plus - deriv_minus) / (F::from(2.0).unwrap() * h)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 101: `result += F::from(i).unwrap() * coeff * t_power;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 114: `let factor = F::from(i * (i - 1)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 350: `let log_h = h.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 351: `let log_e = e.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 359: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 362: `if denominator.abs() < F::from(1e-12).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 368: `let order = (n_f * sum_log_h_log_e - sum_log_h * sum_log_e) / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 371: `let confidence_delta = F::from(0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 431: `Ok((sum_sq / F::from(exact.len()).unwrap()).sqrt())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 476: `Ok((sum_sq / F::from(count).unwrap()).sqrt())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 558: `let analysis = ConvergenceAnalysis::compute_order(grid_sizes, errors).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 570: `let l2_error = ErrorAnalysis::l2_norm(exact.view(), numerical.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 571: `let max_error = ErrorAnalysis::max_norm(exact.view(), numerical.view()).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()

### visualization.rs

21 issues found:

- Line 209: `let param_step = (parameter_range.1 - parameter_range.0) / (n_points - 1) as f64...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 260: `let dx = (x_range.1 - x_range.0) / (nx - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 261: `let dy = (y_range.1 - y_range.0) / (ny - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 277: `magnitude[[i, j]] = (derivative[0].powi(2) + derivative[1].powi(2)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 339: `let i = ((y - y_min) / (y_max - y_min) * (height - 1) as f64) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 340: `let j = ((x - x_min) / (x_max - x_min) * (width - 1) as f64) as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 451: `let dx = (x_max - x_min) / (resolution - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 452: `let dy = (y_max - y_min) / (resolution - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 494: `let param_step = (parameter_range.1 - parameter_range.0) / (n_params - 1) as f64...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 629: `let perturbation = base_parameters[i] * perturbation_percent / 100.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 637: `(perturbed_value - base_value) / perturbation * base_parameters[i] / base_value`
  - **Fix**: Division without zero check - use safe_divide()
- Line 675: `(val - min_val) / range`
  - **Fix**: Division without zero check - use safe_divide()
- Line 731: `let aspect_ratio = width / height;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 732: `let ny = (total_points as f64 / aspect_ratio).sqrt() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 732: `let ny = (total_points as f64 / aspect_ratio).sqrt() as usize;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 741: `let mean = data.iter().sum::<f64>() / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 742: `let variance = data.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 743: `let std_dev = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 746: `sorted_data.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 751: `(sorted_data[sorted_data.len() / 2 - 1] + sorted_data[sorted_data.len() / 2]) / ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 753: `sorted_data[sorted_data.len() / 2]`
  - **Fix**: Division without zero check - use safe_divide()